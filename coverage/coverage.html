
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/lirtsman/devhelper-cli/cmd/config.go (50.0%)</option>
				
				<option value="file1">github.com/lirtsman/devhelper-cli/cmd/deploy.go (50.0%)</option>
				
				<option value="file2">github.com/lirtsman/devhelper-cli/cmd/localenv.go (31.7%)</option>
				
				<option value="file3">github.com/lirtsman/devhelper-cli/cmd/localenv_helpers.go (85.7%)</option>
				
				<option value="file4">github.com/lirtsman/devhelper-cli/cmd/localenv_init.go (2.9%)</option>
				
				<option value="file5">github.com/lirtsman/devhelper-cli/cmd/localenv_status.go (13.4%)</option>
				
				<option value="file6">github.com/lirtsman/devhelper-cli/cmd/root.go (15.4%)</option>
				
				<option value="file7">github.com/lirtsman/devhelper-cli/cmd/start.go (9.9%)</option>
				
				<option value="file8">github.com/lirtsman/devhelper-cli/cmd/stop.go (2.5%)</option>
				
				<option value="file9">github.com/lirtsman/devhelper-cli/cmd/version.go (25.0%)</option>
				
				<option value="file10">github.com/lirtsman/devhelper-cli/internal/test/runner.go (0.0%)</option>
				
				<option value="file11">github.com/lirtsman/devhelper-cli/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright © 2025 NAME HERE &lt;EMAIL ADDRESS&gt;

*/
package cmd

import (
        "fmt"

        "github.com/spf13/cobra"
)

// configCmd represents the config command
var configCmd = &amp;cobra.Command{
        Use:   "config",
        Short: "A brief description of your command",
        Long: `A longer description that spans multiple lines and likely contains examples
and usage of using your command. For example:

Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Println("config called")
        }</span>,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(configCmd)

        // Here you will define your flags and configuration settings.

        // Cobra supports Persistent Flags which will work for this command
        // and all subcommands, e.g.:
        // configCmd.PersistentFlags().String("foo", "", "A help for foo")

        // Cobra supports local flags which will only run when this command
        // is called directly, e.g.:
        // configCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright © 2023 ShieldDev

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package cmd

import (
        "fmt"

        "github.com/spf13/cobra"
)

// deployCmd represents the deploy command
var deployCmd = &amp;cobra.Command{
        Use:   "deploy",
        Short: "Deploy ShieldDev resources",
        Long: `Deploy ShieldDev resources to the target environment.
        
This command allows you to deploy various ShieldDev resources such as
applications, services, or infrastructure components to your target environment.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Println("Use one of the deploy subcommands. Run 'devhelper-cli deploy --help' for usage.")
        }</span>,
}

// appCmd represents the deploy app subcommand
var deployAppCmd = &amp;cobra.Command{
        Use:   "app [name]",
        Short: "Deploy an application",
        Long: `Deploy a ShieldDev application to the target environment.
        
This command deploys a specified application with its configuration 
to the target environment.`,
        Args: cobra.MinimumNArgs(1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                appName := args[0]
                env, _ := cmd.Flags().GetString("env")
                fmt.Printf("Deploying application '%s' to '%s' environment...\n", appName, env)
                // Here would be the actual deployment logic
                fmt.Println("Deployment completed successfully!")
        }</span>,
}

// serviceCmd represents the deploy service subcommand
var deployServiceCmd = &amp;cobra.Command{
        Use:   "service [name]",
        Short: "Deploy a service",
        Long: `Deploy a ShieldDev service to the target environment.
        
This command deploys a specified service with its configuration 
to the target environment.`,
        Args: cobra.MinimumNArgs(1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                serviceName := args[0]
                env, _ := cmd.Flags().GetString("env")
                fmt.Printf("Deploying service '%s' to '%s' environment...\n", serviceName, env)
                // Here would be the actual deployment logic
                fmt.Println("Service deployment completed successfully!")
        }</span>,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(deployCmd)

        // Add subcommands to deploy command
        deployCmd.AddCommand(deployAppCmd)
        deployCmd.AddCommand(deployServiceCmd)

        // Add flags to the deploy app command
        deployAppCmd.Flags().StringP("env", "e", "dev", "Target environment (dev, staging, prod)")
        deployAppCmd.Flags().BoolP("force", "f", false, "Force deployment even if validation fails")
        deployAppCmd.Flags().StringP("version", "v", "latest", "Version to deploy")

        // Add flags to the deploy service command
        deployServiceCmd.Flags().StringP("env", "e", "dev", "Target environment (dev, staging, prod)")
        deployServiceCmd.Flags().BoolP("force", "f", false, "Force deployment even if validation fails")
        deployServiceCmd.Flags().StringP("version", "v", "latest", "Version to deploy")
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright © 2023 ShieldDev

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package cmd

import (
        "bufio"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"

        "github.com/spf13/cobra"
)

// Helper function that can be used by subcommands to check if a command is installed
// Make it a variable holding a function so it can be mocked in tests
var isCommandAvailable = func(command string) bool <span class="cov0" title="0">{
        _, err := exec.LookPath(command)
        return err == nil
}</span>

// localenvCmd represents the localenv command
var localenvCmd = &amp;cobra.Command{
        Use:   "localenv",
        Short: "Manage local development environment",
        Long: `Manage the local development environment for ShieldDev applications.

The localenv command provides functionality to start, stop, and manage 
local development components including:
- Dapr runtime
- Temporal server
- Required dependencies and infrastructure

This allows developers to run and test ShieldDev applications locally.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Println("Use one of the localenv subcommands. Run 'devhelper-cli localenv --help' for usage.")
        }</span>,
}

// logsCmd represents the logs command
var logsCmd = &amp;cobra.Command{
        Use:   "logs [component]",
        Short: "View logs for a local development component",
        Long: `View logs for a locally running component like Temporal server.
Optionally follow the logs in real-time.

Examples:
  devhelper-cli localenv logs temporal      # View Temporal server logs
  devhelper-cli localenv logs temporal -f   # Follow Temporal server logs
`,
        Args: cobra.MaximumNArgs(1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                // Determine which component logs to view
                component := "temporal" // Default to temporal
                if len(args) &gt; 0 </span><span class="cov0" title="0">{
                        component = args[0]
                }</span>

                <span class="cov0" title="0">follow, _ := cmd.Flags().GetBool("follow")
                verbose, _ := cmd.Flags().GetBool("verbose")
                lines, _ := cmd.Flags().GetInt("lines")

                // Base logs directory
                logsDir := filepath.Join(os.Getenv("HOME"), ".logs", "devhelper-cli")
                if _, err := os.Stat(logsDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        fmt.Printf("❌ Logs directory not found: %s\n", logsDir)
                        fmt.Println("   No logs have been generated yet. Try starting the component first.")
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">var logPath string

                // Determine the path to the log file based on component
                switch component </span>{
                case "temporal", "temporal-server":<span class="cov0" title="0">
                        logPath = filepath.Join(logsDir, "temporal-server.log")</span>
                default:<span class="cov0" title="0">
                        fmt.Printf("❌ Unknown component: %s\n", component)
                        fmt.Println("   Supported components: temporal")
                        os.Exit(1)</span>
                }

                // Check if log file exists
                <span class="cov0" title="0">if _, err := os.Stat(logPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        fmt.Printf("❌ Log file not found for component '%s': %s\n", component, logPath)
                        fmt.Printf("   Try starting %s first using 'devhelper-cli localenv start'\n", component)
                        os.Exit(1)
                }</span>

                // If follow is false, just display the last N lines of the file
                <span class="cov0" title="0">if !follow </span><span class="cov0" title="0">{
                        // Use tail to display the last N lines
                        tailCmd := exec.Command("tail", "-n", fmt.Sprintf("%d", lines), logPath)
                        tailCmd.Stdout = os.Stdout
                        tailCmd.Stderr = os.Stderr
                        if err := tailCmd.Run(); err != nil </span><span class="cov0" title="0">{
                                if verbose </span><span class="cov0" title="0">{
                                        fmt.Printf("Error running tail: %v\n", err)
                                }</span>
                                // Fallback to Go implementation if tail fails
                                <span class="cov0" title="0">displayLastNLines(logPath, lines)</span>
                        }
                        <span class="cov0" title="0">return</span>
                }

                // For follow mode, use tail -f to stream the logs in real-time
                <span class="cov0" title="0">fmt.Printf("Following logs for %s. Press Ctrl+C to stop...\n", component)
                tailCmd := exec.Command("tail", "-f", "-n", fmt.Sprintf("%d", lines), logPath)
                tailCmd.Stdout = os.Stdout
                tailCmd.Stderr = os.Stderr
                if err := tailCmd.Run(); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error following logs: %v\n", err)
                }</span>
        },
}

// displayLastNLines reads the last N lines from a file
// Used as a fallback if the tail command is not available
func displayLastNLines(filePath string, n int) <span class="cov8" title="1">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Printf("Error opening log file: %v\n", err)
                return
        }</span>
        <span class="cov8" title="1">defer file.Close()

        scanner := bufio.NewScanner(file)
        lines := make([]string, 0, n)

        // Scan all lines, keeping only the last n
        for scanner.Scan() </span><span class="cov8" title="1">{
                if len(lines) &gt;= n </span><span class="cov8" title="1">{
                        lines = append(lines[1:], scanner.Text())
                }</span> else<span class="cov8" title="1"> {
                        lines = append(lines, scanner.Text())
                }</span>
        }

        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error reading log file: %v\n", err)
                return
        }</span>

        <span class="cov8" title="1">for _, line := range lines </span><span class="cov8" title="1">{
                fmt.Println(line)
        }</span>
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(localenvCmd)

        // Add logs command
        localenvCmd.AddCommand(logsCmd)

        // Add flags for logs command
        logsCmd.Flags().BoolP("follow", "f", false, "Follow the logs (like tail -f)")
        logsCmd.Flags().IntP("lines", "n", 50, "Number of lines to display")

        // Add persistent flags that are available to all subcommands
        localenvCmd.PersistentFlags().BoolP("verbose", "v", false, "Enable verbose output")

        // Here you will define your flags and configuration settings.

        // Cobra supports Persistent Flags which will work for this command
        // and all subcommands, e.g.:
        // localenvCmd.PersistentFlags().String("foo", "", "A help for foo")

        // Cobra supports local flags which will only run when this command
        // is called directly, e.g.:
        // localenvCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright © 2023 ShieldDev

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package cmd

import (
        "fmt"
        "os"
        "os/exec"
        "strconv"
        "time"
)

// Check if a Temporal namespace exists
func isTemporalNamespaceExist(namespace string) bool <span class="cov8" title="1">{
        cmd := exec.Command("temporal", "operator", "namespace", "describe", namespace)
        return cmd.Run() == nil
}</span>

// Helper functions for determining if components are required
func getDaprRequirement(configLoaded bool, configValue bool, skipFlag bool) bool <span class="cov8" title="1">{
        if configLoaded </span><span class="cov8" title="1">{
                return configValue
        }</span>
        <span class="cov8" title="1">return !skipFlag</span>
}

func getTemporalRequirement(configLoaded bool, configValue bool, skipFlag bool) bool <span class="cov8" title="1">{
        if configLoaded </span><span class="cov8" title="1">{
                return configValue
        }</span>
        <span class="cov8" title="1">return !skipFlag</span>
}

func getDaprDashboardRequirement(configLoaded bool, configValue bool, skipFlag bool) bool <span class="cov8" title="1">{
        if configLoaded </span><span class="cov8" title="1">{
                return configValue
        }</span>
        <span class="cov8" title="1">return !skipFlag</span>
}

func tryStartDashboard(command string, port int, logFile *os.File) bool <span class="cov0" title="0">{
        return tryStartDashboardWithTimeout(command, port, logFile, 3*time.Second)
}</span>

func tryStartDashboardWithTimeout(command string, port int, logFile *os.File, timeout time.Duration) bool <span class="cov8" title="1">{
        dashboardCmd := exec.Command(command, "dashboard", "-p", strconv.Itoa(port), "--address", "0.0.0.0")

        // Redirect output to null device or log file
        if logFile == nil </span><span class="cov8" title="1">{
                devNull, _ := os.OpenFile(os.DevNull, os.O_WRONLY, 0)
                dashboardCmd.Stdout = devNull
                dashboardCmd.Stderr = devNull
        }</span> else<span class="cov0" title="0"> {
                dashboardCmd.Stdout = logFile
                dashboardCmd.Stderr = logFile
        }</span>

        // Start the dashboard in a goroutine
        <span class="cov8" title="1">resultChan := make(chan error, 1)
        go func() </span><span class="cov8" title="1">{
                resultChan &lt;- dashboardCmd.Run()
        }</span>()

        // Wait a bit for the dashboard to start
        <span class="cov8" title="1">time.Sleep(timeout)

        // Check if the process exited quickly (indicating failure)
        select </span>{
        case err := &lt;-resultChan:<span class="cov8" title="1">
                // If we get here, the process exited before our timeout
                if err != nil </span><span class="cov8" title="1">{
                        fmt.Printf("Dashboard failed to start: %v\n", err)
                }</span>
                <span class="cov8" title="1">return false</span>
        default:<span class="cov0" title="0">
                // No error yet, process is still running
                return true</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Copyright © 2023 ShieldDev

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package cmd

import (
        "fmt"
        "os"
        "os/exec"
        "strings"

        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"
)

// LocalEnvConfig represents the configuration for the local environment
type LocalEnvConfig struct {
        Components struct {
                Dapr          bool `yaml:"dapr"`
                Temporal      bool `yaml:"temporal"`
                DaprDashboard bool `yaml:"daprDashboard"`
        } `yaml:"components"`
        Paths struct {
                Podman   string `yaml:"podman"`
                Kind     string `yaml:"kind"`
                Dapr     string `yaml:"dapr"`
                Temporal string `yaml:"temporal"`
        } `yaml:"paths"`
        Temporal struct {
                Namespace string `yaml:"namespace"`
                UIPort    int    `yaml:"uiPort"`
                GRPCPort  int    `yaml:"grpcPort"`
        } `yaml:"temporal"`
        Dapr struct {
                DashboardPort int `yaml:"dashboardPort"`
                ZipkinPort    int `yaml:"zipkinPort"`
        } `yaml:"dapr"`
}

// initCmd represents the init command
var localenvInitCmd = &amp;cobra.Command{
        Use:   "init",
        Short: "Initialize local development environment configuration",
        Long: `Initialize the local development environment by:
1. Validating required tools (Podman, Kind, Dapr CLI, Temporal CLI)
2. Creating a configuration file (localenv.yaml) in the current directory
3. Allowing you to customize which components to enable

This command should be run once before using other localenv commands.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Println("Initializing local development environment...")

                force, _ := cmd.Flags().GetBool("force")
                verbose, _ := cmd.Flags().GetBool("verbose")

                // Check if localenv.yaml already exists
                configPath := "localenv.yaml"
                if _, err := os.Stat(configPath); err == nil &amp;&amp; !force </span><span class="cov0" title="0">{
                        fmt.Println("❌ Configuration file already exists. Use --force to overwrite.")
                        return
                }</span>

                // Initialize default configuration
                <span class="cov0" title="0">config := LocalEnvConfig{}
                config.Components.Dapr = true
                config.Components.Temporal = true
                config.Components.DaprDashboard = false // Disabled by default since it requires separate installation

                // Set default Temporal configuration
                config.Temporal.Namespace = "default"
                config.Temporal.UIPort = 8233
                config.Temporal.GRPCPort = 7233

                // Set default Dapr configuration
                config.Dapr.DashboardPort = 8080
                config.Dapr.ZipkinPort = 9411

                // Check for required tools and record their paths
                fmt.Println("\n=== Validating Required Tools ===")

                // Check Podman
                podmanPath, podmanErr := validateTool("podman", "--version", verbose)
                if podmanErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("❌ Podman: %v\n", podmanErr)
                        fmt.Println("   Please install Podman from: https://podman.io/getting-started/installation")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("✅ Podman: Found at %s\n", podmanPath)
                        config.Paths.Podman = podmanPath

                        // Check if Podman can run containers
                        cmd := exec.Command(podmanPath, "ps")
                        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                                fmt.Println("⚠️  Podman is installed but may not be configured correctly to run containers")
                                fmt.Println("   Make sure you have proper permissions and Podman is configured correctly")
                        }</span>
                }

                // Check Kind
                <span class="cov0" title="0">kindPath, kindErr := validateTool("kind", "--version", verbose)
                if kindErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("❌ Kind: %v\n", kindErr)
                        fmt.Println("   Please install Kind from: https://kind.sigs.k8s.io/docs/user/quick-start/#installation")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("✅ Kind: Found at %s\n", kindPath)
                        config.Paths.Kind = kindPath

                        // Check if Kind has any clusters configured
                        clusterCmd := exec.Command(kindPath, "get", "clusters")
                        output, err := clusterCmd.CombinedOutput()
                        if err != nil || strings.TrimSpace(string(output)) == "" </span><span class="cov0" title="0">{
                                fmt.Println("⚠️  Kind is installed but no clusters are configured")
                                fmt.Println("   Note: Kubernetes functionality is not required for local development")
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("   Clusters found: %s\n", strings.ReplaceAll(string(output), "\n", ", "))
                        }</span>
                }

                // Check Dapr CLI
                <span class="cov0" title="0">daprPath, daprErr := validateTool("dapr", "--version", verbose)
                if daprErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("❌ Dapr CLI: %v\n", daprErr)
                        fmt.Println("   Please install Dapr CLI from: https://docs.dapr.io/getting-started/install-dapr-cli/")
                        config.Components.Dapr = false
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("✅ Dapr CLI: Found at %s\n", daprPath)
                        config.Paths.Dapr = daprPath

                        // Check if Docker is available (for original Dapr support)
                        dockerAvailable := isCommandAvailable("docker")

                        // If Podman is available but Docker is not, add a note about using --container-runtime
                        if podmanErr == nil &amp;&amp; !dockerAvailable </span><span class="cov0" title="0">{
                                fmt.Println("   Note: Dapr will be initialized with '--container-runtime podman' since Docker is not available")
                                fmt.Println("   This will start Redis, Zipkin, placement, and scheduler containers using Podman")
                        }</span>

                        // Check if Dapr is initialized
                        <span class="cov0" title="0">listCmd := exec.Command(daprPath, "list")
                        if err := listCmd.Run(); err != nil </span><span class="cov0" title="0">{
                                fmt.Println("⚠️  Dapr CLI is installed but Dapr may not be initialized")
                                fmt.Println("   Dapr will be initialized when you run 'devhelper-cli localenv start'")
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println("   Dapr is initialized and ready to use")
                        }</span>

                        // Check if Dapr Dashboard is available
                        <span class="cov0" title="0">dashboardCmd := exec.Command(daprPath, "dashboard", "--help")
                        if err := dashboardCmd.Run(); err == nil </span><span class="cov0" title="0">{
                                fmt.Println("✅ Dapr Dashboard: Available")
                                fmt.Println("   Run with: 'dapr dashboard'")
                                fmt.Println("   Or use 'devhelper-cli localenv start' with the Dapr Dashboard enabled")

                                // Enable Dapr Dashboard by default if available
                                config.Components.DaprDashboard = true
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println("ℹ️ Dapr Dashboard: Not available")
                                fmt.Println("   Install with: 'dapr dashboard install'")
                                config.Components.DaprDashboard = false
                        }</span>
                }

                // Check Temporal CLI
                <span class="cov0" title="0">temporalPath, temporalErr := validateTool("temporal", "--version", verbose)
                if temporalErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("❌ Temporal CLI: %v\n", temporalErr)
                        fmt.Println("   Please install Temporal CLI from: https://docs.temporal.io/cli#install")
                        config.Components.Temporal = false
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("✅ Temporal CLI: Found at %s\n", temporalPath)
                        config.Paths.Temporal = temporalPath
                }</span>

                // Write configuration to file
                <span class="cov0" title="0">configData, err := yaml.Marshal(config)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("❌ Failed to generate configuration: %v\n", err)
                        return
                }</span>

                <span class="cov0" title="0">if err := os.WriteFile(configPath, configData, 0644); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("❌ Failed to write configuration file: %v\n", err)
                        return
                }</span>

                <span class="cov0" title="0">fmt.Printf("\n✅ Configuration written to %s\n", configPath)
                fmt.Println("\nYou can now use 'devhelper-cli localenv start' to start the local environment")
                fmt.Println("or edit the configuration file to customize enabled components.")

                // Print a summary of enabled components
                fmt.Println("\n=== Enabled Components ===")
                if config.Components.Dapr </span><span class="cov0" title="0">{
                        fmt.Println("✅ Dapr: Enabled")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("❌ Dapr: Disabled (install Dapr CLI to enable)")
                }</span>

                <span class="cov0" title="0">if config.Components.DaprDashboard </span><span class="cov0" title="0">{
                        fmt.Println("✅ Dapr Dashboard: Enabled")
                }</span> else<span class="cov0" title="0"> if config.Components.Dapr </span><span class="cov0" title="0">{
                        fmt.Println("❌ Dapr Dashboard: Disabled (install with 'dapr dashboard install')")
                }</span>

                <span class="cov0" title="0">if config.Components.Temporal </span><span class="cov0" title="0">{
                        fmt.Println("✅ Temporal: Enabled")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("❌ Temporal: Disabled (install Temporal CLI to enable)")
                }</span>
        },
}

func validateTool(name, versionFlag string, verbose bool) (string, error) <span class="cov0" title="0">{
        // Check if the tool is in PATH
        path, err := exec.LookPath(name)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("not found in PATH")
        }</span>

        // Check if the tool works by running version command
        <span class="cov0" title="0">cmd := exec.Command(path, versionFlag)
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return path, fmt.Errorf("found but failed to run: %v", err)
        }</span>

        <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                fmt.Printf("   %s version output: %s\n", name, strings.TrimSpace(string(output)))
        }</span>

        <span class="cov0" title="0">return path, nil</span>
}

func init() <span class="cov8" title="1">{
        localenvCmd.AddCommand(localenvInitCmd)

        // Add flags
        localenvInitCmd.Flags().BoolP("force", "f", false, "Force overwrite of existing configuration")
        localenvInitCmd.Flags().BoolP("verbose", "v", false, "Enable verbose output")
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
Copyright © 2023 ShieldDev

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package cmd

import (
        "fmt"
        "net/http"
        "os"
        "os/exec"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"
)

// statusCmd represents the status command for localenv
var localenvStatusCmd = &amp;cobra.Command{
        Use:   "status",
        Short: "Check status of local development environment",
        Long: `Check the status of the local development environment components.

This command will check if all required components for the local development
environment are running, including:
- Dapr runtime
- Temporal server
- Related dependencies`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Println("Checking local environment status...")

                verbose, _ := cmd.Flags().GetBool("verbose")
                configPath, _ := cmd.Flags().GetString("config")

                // If no config path is provided, look for localenv.yaml in current directory
                if configPath == "" </span><span class="cov0" title="0">{
                        configPath = "localenv.yaml"
                }</span>

                // Load configuration if available
                <span class="cov0" title="0">config := LocalEnvConfig{}
                configLoaded := false

                // Check if config file exists
                if _, err := os.Stat(configPath); err == nil </span><span class="cov0" title="0">{
                        // Read and parse configuration
                        configData, err := os.ReadFile(configPath)
                        if err == nil </span><span class="cov0" title="0">{
                                err = yaml.Unmarshal(configData, &amp;config)
                                if err == nil </span><span class="cov0" title="0">{
                                        configLoaded = true
                                        fmt.Printf("✅ Loaded configuration from %s\n", configPath)
                                }</span> else<span class="cov0" title="0"> if verbose </span><span class="cov0" title="0">{
                                        fmt.Printf("⚠️ Failed to parse configuration: %v\n", err)
                                }</span>
                        } else<span class="cov0" title="0"> if verbose </span><span class="cov0" title="0">{
                                fmt.Printf("⚠️ Failed to read configuration: %v\n", err)
                        }</span>
                } else<span class="cov0" title="0"> if verbose </span><span class="cov0" title="0">{
                        fmt.Printf("⚠️ Configuration file not found at %s\n", configPath)
                        fmt.Println("   Run 'devhelper-cli localenv init' to create a configuration")
                }</span>

                // Define status checks for each component
                <span class="cov0" title="0">components := []struct {
                        Name          string
                        CheckCommand  string
                        CheckArgs     []string
                        StatusMessage string
                        Available     bool
                        Enabled       bool
                        WebUIURL      string
                        CheckUI       bool
                        IsBinary      bool
                }{
                        {
                                Name:         "Podman",
                                CheckCommand: "podman",
                                CheckArgs:    []string{"ps", "--format", "{{.Names}} - {{.Status}}"},
                                Available:    isCommandAvailable("podman"),
                                Enabled:      true, // Always required
                                IsBinary:     true,
                        },
                        {
                                Name:         "Kind",
                                CheckCommand: "kind",
                                CheckArgs:    []string{"get", "clusters"},
                                Available:    isCommandAvailable("kind"),
                                Enabled:      true, // Always required
                                IsBinary:     true,
                        },
                        {
                                Name:         "Dapr",
                                CheckCommand: "dapr",
                                CheckArgs:    []string{"list"},
                                Available:    isCommandAvailable("dapr"),
                                Enabled:      getDaprStatusRequirement(configLoaded, config.Components.Dapr),
                                WebUIURL:     getDaprWebUIURL(configLoaded, config),
                                CheckUI:      isDaprDashboardAvailable(),
                                IsBinary:     false,
                        },
                        {
                                Name:         "Temporal",
                                CheckCommand: "temporal",
                                CheckArgs:    getTemporalNamespaceArgs(configLoaded, config),
                                Available:    isCommandAvailable("temporal"),
                                Enabled:      getTemporalStatusRequirement(configLoaded, config.Components.Temporal),
                                WebUIURL:     getTemporalUIURL(configLoaded, config),
                                CheckUI:      true,
                                IsBinary:     false,
                        },
                }

                fmt.Println("\n=== Local Environment Status ===")

                // First check required tools
                fmt.Println("\n== Required Tools ==")
                allToolsInstalled := true
                for _, comp := range components </span><span class="cov0" title="0">{
                        if !comp.Available </span><span class="cov0" title="0">{
                                fmt.Printf("❌ %s: Not installed\n", comp.Name)
                                allToolsInstalled = false
                        }</span> else<span class="cov0" title="0"> if comp.IsBinary </span><span class="cov0" title="0">{
                                fmt.Printf("✅ %s: Installed\n", comp.Name)
                        }</span>
                }

                <span class="cov0" title="0">if !allToolsInstalled </span><span class="cov0" title="0">{
                        fmt.Println("\n❌ Some required tools are not installed.")
                        fmt.Println("Run 'devhelper-cli localenv init' to check required dependencies and create a configuration.")
                        return
                }</span>

                // Check Podman functionality
                <span class="cov0" title="0">fmt.Println("\n== Tool Functionality ==")
                podmanWorking := checkToolFunctionality("podman", []string{"ps"}, verbose)
                if podmanWorking </span><span class="cov0" title="0">{
                        fmt.Println("✅ Podman: Can run containers")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("❌ Podman: Not able to run containers")
                        fmt.Println("   Make sure Podman is installed correctly and has proper permissions.")
                }</span>

                // Check Kind functionality
                <span class="cov0" title="0">kindWorking := checkToolFunctionality("kind", []string{"get", "clusters"}, verbose)
                if kindWorking </span><span class="cov0" title="0">{
                        // Execute kind get clusters and check if any clusters are listed
                        cmd := exec.Command("kind", "get", "clusters")
                        output, err := cmd.Output()
                        outputStr := strings.TrimSpace(string(output))

                        if err == nil &amp;&amp; outputStr != "" </span><span class="cov0" title="0">{
                                fmt.Println("✅ Kind: Clusters configured")
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println("✅ Kind: Tool working, but no clusters configured")
                                fmt.Println("   Note: Kubernetes functionality is not required for local development.")
                        }</span>
                } else<span class="cov0" title="0"> {
                        fmt.Println("❌ Kind: No clusters available")
                        fmt.Println("   Note: Kubernetes functionality is not required for local development.")
                }</span>

                <span class="cov0" title="0">if !podmanWorking || !kindWorking </span><span class="cov0" title="0">{
                        fmt.Println("\n❌ Required tools are not working properly.")
                        fmt.Println("Fix the issues above before continuing.")
                        return
                }</span>

                // Check enabled services
                <span class="cov0" title="0">fmt.Println("\n== Enabled Components ==")
                allRunning := true
                anyEnabled := false

                for _, comp := range components </span><span class="cov0" title="0">{
                        if !comp.Enabled || comp.IsBinary </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">anyEnabled = true

                        // Special handling for Dapr
                        if comp.Name == "Dapr" </span><span class="cov0" title="0">{
                                // Check if Dapr binaries exist
                                _, err := os.Stat(filepath.Join(os.Getenv("HOME"), ".dapr", "bin", "daprd"))
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("❌ %s: Not initialized\n", comp.Name)
                                        fmt.Println("   Run 'devhelper-cli localenv start' to initialize Dapr")
                                        allRunning = false
                                        continue</span>
                                }

                                // Check if we can run dapr list
                                <span class="cov0" title="0">cmd := exec.Command("dapr", "list")
                                output, err := cmd.CombinedOutput()
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("❌ %s: Not running properly\n", comp.Name)
                                        if verbose &amp;&amp; len(output) &gt; 0 </span><span class="cov0" title="0">{
                                                fmt.Printf("   Details: %s\n", strings.TrimSpace(string(output)))
                                        }</span>
                                        <span class="cov0" title="0">allRunning = false
                                        continue</span>
                                }

                                <span class="cov0" title="0">fmt.Printf("✅ %s: Running\n", comp.Name)
                                if verbose </span><span class="cov0" title="0">{
                                        fmt.Println("   No Dapr apps are currently running, but the runtime is available")
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }

                        // Standard check for other components
                        <span class="cov0" title="0">cmd := exec.Command(comp.CheckCommand, comp.CheckArgs...)
                        output, err := cmd.CombinedOutput()
                        outputStr := strings.TrimSpace(string(output))

                        if err != nil </span><span class="cov0" title="0">{
                                // Special case for Temporal - sometimes workflow list returns an error even when Temporal is running
                                if comp.Name == "Temporal" </span><span class="cov0" title="0">{
                                        // Try a simpler check - just use the UI availability as the primary indicator
                                        client := http.Client{
                                                Timeout: 2 * time.Second,
                                        }
                                        resp, err := client.Get(comp.WebUIURL)
                                        if err == nil &amp;&amp; resp.StatusCode &lt; 400 </span><span class="cov0" title="0">{
                                                resp.Body.Close()
                                                fmt.Printf("✅ %s: Running\n", comp.Name)
                                                fmt.Printf("   UI: %s (Accessible)\n", comp.WebUIURL)
                                                continue</span>
                                        }
                                }

                                <span class="cov0" title="0">fmt.Printf("❌ %s: Not running\n", comp.Name)
                                if verbose &amp;&amp; outputStr != "" </span><span class="cov0" title="0">{
                                        fmt.Printf("   Details: %s\n", outputStr)
                                }</span>
                                <span class="cov0" title="0">allRunning = false
                                continue</span>
                        }

                        <span class="cov0" title="0">fmt.Printf("✅ %s: Running\n", comp.Name)

                        // For Temporal, check if the UI is accessible
                        if comp.CheckUI &amp;&amp; comp.WebUIURL != "" </span><span class="cov0" title="0">{
                                uiAccessible := false
                                client := http.Client{
                                        Timeout: 2 * time.Second,
                                }
                                resp, err := client.Get(comp.WebUIURL)
                                if err == nil &amp;&amp; resp.StatusCode &lt; 400 </span><span class="cov0" title="0">{
                                        uiAccessible = true
                                        resp.Body.Close()
                                }</span>

                                <span class="cov0" title="0">if uiAccessible </span><span class="cov0" title="0">{
                                        fmt.Printf("   UI: %s (Accessible)\n", comp.WebUIURL)
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("   UI: %s (Not accessible yet, may still be starting up)\n", comp.WebUIURL)
                                }</span>

                                // Check if the configured namespace exists (if not default)
                                <span class="cov0" title="0">if comp.Name == "Temporal" &amp;&amp; configLoaded &amp;&amp; config.Components.Temporal &amp;&amp; config.Temporal.Namespace != "" &amp;&amp; config.Temporal.Namespace != "default" </span><span class="cov0" title="0">{
                                        namespaceCmd := exec.Command("temporal", "operator", "namespace", "describe", config.Temporal.Namespace)
                                        if err := namespaceCmd.Run(); err != nil </span><span class="cov0" title="0">{
                                                fmt.Printf("   ⚠️ Namespace '%s' does not exist. It will be created when starting the environment.\n", config.Temporal.Namespace)
                                        }</span> else<span class="cov0" title="0"> {
                                                fmt.Printf("   ✅ Temporal namespace '%s' exists\n", config.Temporal.Namespace)
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">if verbose &amp;&amp; outputStr != "" </span><span class="cov0" title="0">{
                                // Format and print relevant output details
                                lines := strings.Split(outputStr, "\n")
                                if len(lines) &gt; 5 &amp;&amp; !verbose </span><span class="cov0" title="0">{
                                        // Truncate output if it's too long and we're not in verbose mode
                                        for i := 0; i &lt; 3; i++ </span><span class="cov0" title="0">{
                                                if i &lt; len(lines) </span><span class="cov0" title="0">{
                                                        fmt.Printf("   %s\n", lines[i])
                                                }</span>
                                        }
                                        <span class="cov0" title="0">fmt.Printf("   ... %d more lines ...\n", len(lines)-3)</span>
                                } else<span class="cov0" title="0"> {
                                        for _, line := range lines </span><span class="cov0" title="0">{
                                                fmt.Printf("   %s\n", line)
                                        }</span>
                                }
                        }
                }

                <span class="cov0" title="0">if !anyEnabled </span><span class="cov0" title="0">{
                        fmt.Println("ℹ️ No components are enabled in the configuration.")
                        fmt.Println("   Edit localenv.yaml to enable components or run 'devhelper-cli localenv init' to create a new config.")
                        return
                }</span>

                <span class="cov0" title="0">fmt.Println("\n=== Summary ===")
                if allRunning </span><span class="cov0" title="0">{
                        fmt.Println("✅ All components are running properly.")

                        // Show concise component information
                        if configLoaded &amp;&amp; config.Components.Temporal </span><span class="cov0" title="0">{
                                // Extract Temporal configuration values
                                uiPort := 8233
                                grpcPort := 7233
                                namespace := "default"

                                if config.Temporal.UIPort != 0 </span><span class="cov0" title="0">{
                                        uiPort = config.Temporal.UIPort
                                }</span>
                                <span class="cov0" title="0">if config.Temporal.GRPCPort != 0 </span><span class="cov0" title="0">{
                                        grpcPort = config.Temporal.GRPCPort
                                }</span>
                                <span class="cov0" title="0">if config.Temporal.Namespace != "" </span><span class="cov0" title="0">{
                                        namespace = config.Temporal.Namespace
                                }</span>

                                <span class="cov0" title="0">fmt.Printf("\nTemporal UI: http://localhost:%d\n", uiPort)
                                fmt.Printf("Temporal Server: localhost:%d (namespace: %s)\n", grpcPort, namespace)</span>
                        }

                        // Show Dapr connection information if enabled
                        <span class="cov0" title="0">if configLoaded &amp;&amp; config.Components.Dapr </span><span class="cov0" title="0">{
                                // Check for Dapr Dashboard
                                if isDaprDashboardAvailable() </span><span class="cov0" title="0">{
                                        dashboardURL := getDaprDashboardURL(configLoaded, config)
                                        if isDaprDashboardAccessible(dashboardURL) </span><span class="cov0" title="0">{
                                                fmt.Printf("\nDapr Dashboard: %s\n", dashboardURL)
                                        }</span> else<span class="cov0" title="0"> {
                                                fmt.Printf("\nDapr Dashboard: %s (Not accessible)\n", dashboardURL)
                                                fmt.Println("   If the dashboard is running but not accessible on this port,")
                                                fmt.Println("   update the dashboardPort in localenv.yaml and restart the environment.")
                                        }</span>
                                }

                                // Show Zipkin URL for tracing
                                <span class="cov0" title="0">zipkinURL := getZipkinURL(configLoaded, config)
                                fmt.Printf("Zipkin UI (tracing): %s\n", zipkinURL)

                                // Check if Dapr containers are running using podman
                                cmd := exec.Command("podman", "ps", "--format", "{{.Names}}", "--filter", "name=dapr_")
                                output, err := cmd.CombinedOutput()
                                if err == nil &amp;&amp; len(output) &gt; 0 </span><span class="cov0" title="0">{
                                        fmt.Println("\nDapr Services:")
                                        containers := strings.Split(strings.TrimSpace(string(output)), "\n")
                                        for _, container := range containers </span><span class="cov0" title="0">{
                                                if container == "" </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                                <span class="cov0" title="0">fmt.Printf("- %s\n", container)</span>
                                        }

                                        // Check if Dapr Dashboard process is running
                                        <span class="cov0" title="0">dashboardPID := getDaprDashboardPID()
                                        if dashboardPID != "" </span><span class="cov0" title="0">{
                                                fmt.Println("- dapr_dashboard")
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        // If we couldn't find containers but the dashboard is running, still show it
                                        dashboardPID := getDaprDashboardPID()
                                        if dashboardPID != "" </span><span class="cov0" title="0">{
                                                fmt.Println("\nDapr Services:")
                                                fmt.Println("- dapr_dashboard")
                                        }</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        fmt.Println("⚠️  Some components are not running.")
                        fmt.Println("Run 'devhelper-cli localenv start' to start the environment.")
                }</span>
        },
}

// Helper function to check if a tool is working properly
func checkToolFunctionality(command string, args []string, verbose bool) bool <span class="cov0" title="0">{
        cmd := exec.Command(command, args...)
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                if verbose </span><span class="cov0" title="0">{
                        fmt.Printf("   Details: %s\n", strings.TrimSpace(string(output)))
                }</span>
                <span class="cov0" title="0">return false</span>
        }
        <span class="cov0" title="0">return true</span>
}

// Helper functions for status command
func getDaprStatusRequirement(configLoaded bool, configValue bool) bool <span class="cov8" title="1">{
        if configLoaded </span><span class="cov8" title="1">{
                return configValue
        }</span>
        <span class="cov8" title="1">return true</span>
}

func getTemporalStatusRequirement(configLoaded bool, configValue bool) bool <span class="cov8" title="1">{
        if configLoaded </span><span class="cov8" title="1">{
                return configValue
        }</span>
        <span class="cov8" title="1">return true</span>
}

// Helper function to get Temporal namespace args
func getTemporalNamespaceArgs(configLoaded bool, config LocalEnvConfig) []string <span class="cov8" title="1">{
        namespace := "default"
        if configLoaded &amp;&amp; config.Temporal.Namespace != "" </span><span class="cov8" title="1">{
                namespace = config.Temporal.Namespace
        }</span>
        <span class="cov8" title="1">return []string{"operator", "namespace", "describe", namespace}</span>
}

// Helper function to get Temporal UI URL
func getTemporalUIURL(configLoaded bool, config LocalEnvConfig) string <span class="cov8" title="1">{
        uiPort := 8233

        if configLoaded &amp;&amp; config.Temporal.UIPort != 0 </span><span class="cov8" title="1">{
                uiPort = config.Temporal.UIPort
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("http://localhost:%d", uiPort)</span>
}

// Helper function to check if Dapr Dashboard is available
func isDaprDashboardAvailable() bool <span class="cov8" title="1">{
        // Check if dapr dashboard command is available
        cmd := exec.Command("dapr", "dashboard", "--help")
        err := cmd.Run()
        return err == nil
}</span>

// Helper function to get Dapr Dashboard URL
func getDaprDashboardURL(configLoaded bool, config LocalEnvConfig) string <span class="cov8" title="1">{
        dashboardPort := 8080

        if configLoaded &amp;&amp; config.Dapr.DashboardPort != 0 </span><span class="cov8" title="1">{
                dashboardPort = config.Dapr.DashboardPort
        }</span>

        // Simply return the configured URL
        <span class="cov8" title="1">return fmt.Sprintf("http://localhost:%d", dashboardPort)</span>
}

// Helper function to check if Dapr Dashboard is running and get its PID
func getDaprDashboardPID() string <span class="cov0" title="0">{
        // First try to find the process using ps command
        cmd := exec.Command("ps", "-ef")
        output, err := cmd.CombinedOutput()
        if err == nil </span><span class="cov0" title="0">{
                outputLines := strings.Split(string(output), "\n")
                for _, line := range outputLines </span><span class="cov0" title="0">{
                        if strings.Contains(line, "dapr dashboard") &amp;&amp; !strings.Contains(line, "grep") </span><span class="cov0" title="0">{
                                fields := strings.Fields(line)
                                if len(fields) &gt;= 2 </span><span class="cov0" title="0">{
                                        return fields[1] // Return PID
                                }</span>
                        }
                }
        }

        // If we can't find it with ps, try a different approach using lsof
        // Look for the 'dashboard' process on common Dapr Dashboard ports
        <span class="cov0" title="0">commonPorts := []string{"8080", "8081", "8082", "8083", "8084", "8085"}

        for _, port := range commonPorts </span><span class="cov0" title="0">{
                cmd = exec.Command("lsof", "-i", ":"+port, "-sTCP:LISTEN")
                output, err = cmd.CombinedOutput()
                if err == nil &amp;&amp; len(output) &gt; 0 </span><span class="cov0" title="0">{
                        outputLines := strings.Split(string(output), "\n")
                        for _, line := range outputLines </span><span class="cov0" title="0">{
                                if strings.HasPrefix(line, "dashboard") </span><span class="cov0" title="0">{
                                        fields := strings.Fields(line)
                                        if len(fields) &gt;= 2 </span><span class="cov0" title="0">{
                                                return fields[1] // Return PID
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return ""</span>
}

// Helper function to check if a specific port is in use
func isPortInUse(port int) bool <span class="cov8" title="1">{
        cmd := exec.Command("lsof", "-i", ":"+strconv.Itoa(port), "-sTCP:LISTEN")
        output, err := cmd.CombinedOutput()
        return err == nil &amp;&amp; len(output) &gt; 0
}</span>

// Helper function to check if Dapr Dashboard is accessible
func isDaprDashboardAccessible(url string) bool <span class="cov0" title="0">{
        client := http.Client{
                Timeout: 2 * time.Second,
        }
        resp, err := client.Get(url)
        if err == nil </span><span class="cov0" title="0">{
                resp.Body.Close()
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Helper function to get Dapr Dashboard URL with availability check
func getDaprWebUIURL(configLoaded bool, config LocalEnvConfig) string <span class="cov8" title="1">{
        if !isDaprDashboardAvailable() </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">return getDaprDashboardURL(configLoaded, config)</span>
}

// Helper function to get Zipkin URL
func getZipkinURL(configLoaded bool, config LocalEnvConfig) string <span class="cov8" title="1">{
        zipkinPort := 9411

        if configLoaded &amp;&amp; config.Dapr.ZipkinPort != 0 </span><span class="cov8" title="1">{
                zipkinPort = config.Dapr.ZipkinPort
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("http://localhost:%d", zipkinPort)</span>
}

func init() <span class="cov8" title="1">{
        localenvCmd.AddCommand(localenvStatusCmd)
        localenvStatusCmd.Flags().StringP("config", "c", "", "Path to environment configuration file (default: localenv.yaml)")
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
Copyright © 2023 ShieldDev

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package cmd

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var cfgFile string

// rootCmd represents the base command when called without any subcommands
var rootCmd = &amp;cobra.Command{
        Use:   "devhelper-cli",
        Short: "A CLI tool for ShieldDev operations",
        Long: `devhelper-cli is a comprehensive command line interface tool
designed to streamline and automate ShieldDev operations.

This tool provides various commands to help developers and operators
manage ShieldDev resources efficiently from the command line.`,
        // Uncomment the following line if your bare application
        // has an action associated with it:
        // Run: func(cmd *cobra.Command, args []string) { },
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                os.Exit(1)
        }</span>
}

func init() <span class="cov8" title="1">{
        cobra.OnInitialize(initConfig)

        // Here you will define your flags and configuration settings.
        // Cobra supports persistent flags, which, if defined here,
        // will be global for your application.
        rootCmd.PersistentFlags().StringVar(&amp;cfgFile, "config", "", "config file (default is $HOME/.devhelper-cli.yaml)")

        // Example of a flag that can be used from any subcommand
        rootCmd.PersistentFlags().Bool("verbose", false, "Enable verbose output")
        viper.BindPFlag("verbose", rootCmd.PersistentFlags().Lookup("verbose"))
}</span>

// initConfig reads in config file and ENV variables if set.
func initConfig() <span class="cov0" title="0">{
        if cfgFile != "" </span><span class="cov0" title="0">{
                // Use config file from the flag.
                viper.SetConfigFile(cfgFile)
        }</span> else<span class="cov0" title="0"> {
                // Find home directory.
                home, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span>

                // Search config in home directory with name ".devhelper-cli" (without extension).
                <span class="cov0" title="0">viper.AddConfigPath(home)
                viper.SetConfigType("yaml")
                viper.SetConfigName(".devhelper-cli")

                // Also look for config in the current directory
                cwd, err := os.Getwd()
                if err == nil </span><span class="cov0" title="0">{
                        viper.AddConfigPath(cwd)

                        // And in a .shielddev directory if it exists
                        shielddevDir := filepath.Join(cwd, ".shielddev")
                        if _, err := os.Stat(shielddevDir); err == nil </span><span class="cov0" title="0">{
                                viper.AddConfigPath(shielddevDir)
                        }</span>
                }
        }

        // If a config file is found, read it in.
        <span class="cov0" title="0">if err := viper.ReadInConfig(); err == nil </span><span class="cov0" title="0">{
                fmt.Println("Using config file:", viper.ConfigFileUsed())
        }</span>

        // Read environment variables prefixed with SHIELDDEV_
        <span class="cov0" title="0">viper.SetEnvPrefix("SHIELDDEV")
        viper.AutomaticEnv()</span> // read in environment variables that match
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Copyright © 2023 ShieldDev

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package cmd

import (
        "fmt"
        "io"
        "os"
        "os/exec"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"
)

// Configuration cache to detect changes between runs
type ConfigCache struct {
        DaprDashboardPort int
        TemporalUIPort    int
        TemporalGRPCPort  int
        TemporalNamespace string
}

// Returns true if current config differs from previous state
func hasConfigChanged(config LocalEnvConfig, currentCache ConfigCache) (bool, ConfigCache, []string) <span class="cov8" title="1">{
        changes := []string{}
        newCache := ConfigCache{
                DaprDashboardPort: config.Dapr.DashboardPort,
                TemporalUIPort:    config.Temporal.UIPort,
                TemporalGRPCPort:  config.Temporal.GRPCPort,
                TemporalNamespace: config.Temporal.Namespace,
        }

        hasChanges := false

        // Check for dashboard port change
        if currentCache.DaprDashboardPort != 0 &amp;&amp;
                currentCache.DaprDashboardPort != config.Dapr.DashboardPort </span><span class="cov8" title="1">{
                changes = append(changes, fmt.Sprintf("Dapr Dashboard port changed: %d → %d",
                        currentCache.DaprDashboardPort, config.Dapr.DashboardPort))
                hasChanges = true
        }</span>

        // Check for Temporal UI port change
        <span class="cov8" title="1">if currentCache.TemporalUIPort != 0 &amp;&amp;
                currentCache.TemporalUIPort != config.Temporal.UIPort </span><span class="cov8" title="1">{
                changes = append(changes, fmt.Sprintf("Temporal UI port changed: %d → %d",
                        currentCache.TemporalUIPort, config.Temporal.UIPort))
                hasChanges = true
        }</span>

        // Check for Temporal GRPC port change
        <span class="cov8" title="1">if currentCache.TemporalGRPCPort != 0 &amp;&amp;
                currentCache.TemporalGRPCPort != config.Temporal.GRPCPort </span><span class="cov8" title="1">{
                changes = append(changes, fmt.Sprintf("Temporal GRPC port changed: %d → %d",
                        currentCache.TemporalGRPCPort, config.Temporal.GRPCPort))
                hasChanges = true
        }</span>

        // Check for Temporal namespace change
        <span class="cov8" title="1">if currentCache.TemporalNamespace != "" &amp;&amp;
                currentCache.TemporalNamespace != config.Temporal.Namespace </span><span class="cov8" title="1">{
                changes = append(changes, fmt.Sprintf("Temporal namespace changed: %s → %s",
                        currentCache.TemporalNamespace, config.Temporal.Namespace))
                hasChanges = true
        }</span>

        <span class="cov8" title="1">return hasChanges, newCache, changes</span>
}

// Reads last used configuration from a cache file
func loadConfigCache() ConfigCache <span class="cov8" title="1">{
        cache := ConfigCache{}
        cacheFile := filepath.Join(os.Getenv("HOME"), ".config", "devhelper-cli", "config-cache.yaml")

        if _, err := os.Stat(cacheFile); err == nil </span><span class="cov8" title="1">{
                // Cache file exists, try to read it
                data, err := os.ReadFile(cacheFile)
                if err == nil </span><span class="cov8" title="1">{
                        yaml.Unmarshal(data, &amp;cache)
                }</span>
        }

        <span class="cov8" title="1">return cache</span>
}

// Saves current configuration to a cache file for future comparison
func saveConfigCache(cache ConfigCache) <span class="cov8" title="1">{
        cacheDir := filepath.Join(os.Getenv("HOME"), ".config", "devhelper-cli")
        cacheFile := filepath.Join(cacheDir, "config-cache.yaml")

        // Create directory if it doesn't exist
        if _, err := os.Stat(cacheDir); os.IsNotExist(err) </span><span class="cov8" title="1">{
                os.MkdirAll(cacheDir, 0755)
        }</span>

        <span class="cov8" title="1">data, err := yaml.Marshal(cache)
        if err == nil </span><span class="cov8" title="1">{
                os.WriteFile(cacheFile, data, 0644)
        }</span>
}

// Components to be started
type Component struct {
        Name            string
        Command         string
        Args            []string
        CheckCommand    string
        CheckArgs       []string
        RequiredFor     []string
        StartupDelay    time.Duration
        IsRunning       bool
        IsRequired      bool
        CommandExists   bool
        VerifyAvailable func() bool // Function to verify the component is accessible
        RequiresStartup bool        // Whether the component needs to be started or just verified
        IsBinary        bool        // Whether the component is a binary command (like Podman, Kind) rather than a service
}

// startCmd represents the start command
var startCmd = &amp;cobra.Command{
        Use:   "start",
        Short: "Start local development environment",
        Long: `Start a local development environment with all necessary components
for ShieldDev application development including:

- Dapr runtime
- Temporal server
- Required dependencies

This command will check for necessary dependencies and start them
in the correct order.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Println("Starting local development environment...")

                verbose, _ := cmd.Flags().GetBool("verbose")
                skipDapr, _ := cmd.Flags().GetBool("skip-dapr")
                skipTemporal, _ := cmd.Flags().GetBool("skip-temporal")
                skipDaprDashboard, _ := cmd.Flags().GetBool("skip-dapr-dashboard")
                configPath, _ := cmd.Flags().GetString("config")
                forceRestart, _ := cmd.Flags().GetBool("force-restart")
                streamLogs, _ := cmd.Flags().GetBool("stream-logs")

                // If no config path is provided, look for localenv.yaml in current directory
                if configPath == "" </span><span class="cov0" title="0">{
                        configPath = "localenv.yaml"
                }</span>

                // Load configuration if available
                <span class="cov0" title="0">config := LocalEnvConfig{}
                configLoaded := false

                // Check if config file exists
                if _, err := os.Stat(configPath); err == nil </span><span class="cov0" title="0">{
                        // Read and parse configuration
                        configData, err := os.ReadFile(configPath)
                        if err == nil </span><span class="cov0" title="0">{
                                err = yaml.Unmarshal(configData, &amp;config)
                                if err == nil </span><span class="cov0" title="0">{
                                        configLoaded = true
                                        fmt.Printf("✅ Loaded configuration from %s\n", configPath)
                                }</span> else<span class="cov0" title="0"> if verbose </span><span class="cov0" title="0">{
                                        fmt.Printf("⚠️ Failed to parse configuration: %v\n", err)
                                }</span>
                        } else<span class="cov0" title="0"> if verbose </span><span class="cov0" title="0">{
                                fmt.Printf("⚠️ Failed to read configuration: %v\n", err)
                        }</span>
                } else<span class="cov0" title="0"> if verbose </span><span class="cov0" title="0">{
                        fmt.Printf("⚠️ Configuration file not found at %s\n", configPath)
                        fmt.Println("   Run 'devhelper-cli localenv init' to create a configuration")
                }</span>

                // Load previous configuration cache
                <span class="cov0" title="0">configCache := loadConfigCache()

                // Check if configuration has changed
                configChanged, newCache, changes := hasConfigChanged(config, configCache)

                // If this is a first run (no previous cache), initialize the config cache
                if configCache.DaprDashboardPort == 0 &amp;&amp; configCache.TemporalUIPort == 0 </span><span class="cov0" title="0">{
                        saveConfigCache(newCache)
                }</span>

                // Override config with command line flags
                <span class="cov0" title="0">if skipDapr </span><span class="cov0" title="0">{
                        config.Components.Dapr = false
                }</span>
                <span class="cov0" title="0">if skipTemporal </span><span class="cov0" title="0">{
                        config.Components.Temporal = false
                }</span>
                <span class="cov0" title="0">if skipDaprDashboard </span><span class="cov0" title="0">{
                        config.Components.DaprDashboard = false
                }</span>

                // Function to check if Temporal server is accessible
                <span class="cov0" title="0">checkTemporalServerRunning := func() bool </span><span class="cov0" title="0">{
                        checkCmd := exec.Command("temporal", "operator", "namespace", "list")
                        if err := checkCmd.Run(); err != nil </span><span class="cov0" title="0">{
                                if verbose </span><span class="cov0" title="0">{
                                        fmt.Printf("Temporal server check failed: %v\n", err)
                                }</span>

                                // Try with explicit server address as fallback
                                <span class="cov0" title="0">checkCmdWithAddress := exec.Command("temporal", "operator", "--address", "localhost:7233", "namespace", "list")
                                if err := checkCmdWithAddress.Run(); err != nil </span><span class="cov0" title="0">{
                                        if verbose </span><span class="cov0" title="0">{
                                                fmt.Printf("Temporal server check with explicit address failed: %v\n", err)
                                        }</span>
                                        <span class="cov0" title="0">return false</span>
                                }
                                <span class="cov0" title="0">return true</span>
                        }
                        <span class="cov0" title="0">return true</span>
                }

                // Function to check if Dapr is accessible
                <span class="cov0" title="0">checkDaprRunning := func() bool </span><span class="cov0" title="0">{
                        // For self-hosted mode, we just check if `dapr list` works
                        // The `dapr status` command requires -k which is for Kubernetes
                        listCmd := exec.Command("dapr", "list")
                        _, err := listCmd.CombinedOutput()
                        if err != nil </span><span class="cov0" title="0">{
                                if verbose </span><span class="cov0" title="0">{
                                        fmt.Printf("Dapr check failed: %v\n", err)
                                }</span>
                                <span class="cov0" title="0">return false</span>
                        }

                        // Also verify the Dapr binaries are installed
                        <span class="cov0" title="0">_, err = os.Stat(filepath.Join(os.Getenv("HOME"), ".dapr", "bin", "daprd"))
                        if err != nil </span><span class="cov0" title="0">{
                                if verbose </span><span class="cov0" title="0">{
                                        fmt.Printf("Dapr binaries not found: %v\n", err)
                                }</span>
                                <span class="cov0" title="0">return false</span>
                        }

                        // If the command succeeds and binaries exist, we consider Dapr initialized
                        <span class="cov0" title="0">return true</span>
                }

                // Function to check if Podman is running
                <span class="cov0" title="0">checkPodmanRunning := func() bool </span><span class="cov0" title="0">{
                        checkCmd := exec.Command("podman", "ps")
                        if err := checkCmd.Run(); err != nil </span><span class="cov0" title="0">{
                                if verbose </span><span class="cov0" title="0">{
                                        fmt.Printf("Podman check failed: %v\n", err)
                                }</span>
                                <span class="cov0" title="0">return false</span>
                        }
                        <span class="cov0" title="0">return true</span>
                }

                // Function to check if Kind has clusters
                <span class="cov0" title="0">checkKindRunning := func() bool </span><span class="cov0" title="0">{
                        checkCmd := exec.Command("kind", "get", "clusters")
                        output, err := checkCmd.CombinedOutput()
                        if err != nil </span><span class="cov0" title="0">{
                                if verbose </span><span class="cov0" title="0">{
                                        fmt.Printf("Kind check failed: %v\n", err)
                                }</span>
                                <span class="cov0" title="0">return false</span>
                        }
                        // Check if there's at least one cluster
                        <span class="cov0" title="0">return len(strings.TrimSpace(string(output))) &gt; 0</span>
                }

                // Define the components we need to start
                <span class="cov0" title="0">components := []Component{
                        {
                                Name:            "Podman",
                                Command:         "podman",
                                Args:            []string{"--version"},
                                CheckCommand:    "podman",
                                CheckArgs:       []string{"ps"},
                                RequiredFor:     []string{"Kind", "Dapr", "Temporal"},
                                StartupDelay:    0,
                                IsRequired:      true,
                                CommandExists:   isCommandAvailable("podman"),
                                VerifyAvailable: checkPodmanRunning,
                                RequiresStartup: false, // We don't start Podman, just verify it's running
                                IsBinary:        true,
                        },
                        {
                                Name:            "Kind",
                                Command:         "kind",
                                Args:            []string{"--version"},
                                CheckCommand:    "kind",
                                CheckArgs:       []string{"get", "clusters"},
                                RequiredFor:     []string{"Dapr", "Temporal"},
                                StartupDelay:    0,
                                IsRequired:      true,
                                CommandExists:   isCommandAvailable("kind"),
                                VerifyAvailable: checkKindRunning,
                                RequiresStartup: false, // We don't start Kind, just verify it's configured
                                IsBinary:        true,
                        },
                        {
                                Name:            "Dapr",
                                Command:         "dapr",
                                Args:            []string{"init", "--container-runtime", "podman"},
                                CheckCommand:    "dapr",
                                CheckArgs:       []string{"status"},
                                RequiredFor:     []string{},
                                StartupDelay:    2 * time.Second,
                                IsRequired:      getDaprRequirement(configLoaded, config.Components.Dapr, skipDapr),
                                CommandExists:   isCommandAvailable("dapr"),
                                VerifyAvailable: checkDaprRunning,
                                RequiresStartup: true, // Dapr needs to be started
                                IsBinary:        false,
                        },
                        {
                                Name:         "DaprDashboard",
                                Command:      "dapr",
                                Args:         []string{"dashboard", "-p", strconv.Itoa(config.Dapr.DashboardPort), "--address", "0.0.0.0"},
                                CheckCommand: "dapr",
                                CheckArgs:    []string{"dashboard", "--help"},
                                RequiredFor:  []string{},
                                StartupDelay: 1 * time.Second,
                                IsRequired:   getDaprDashboardRequirement(configLoaded, config.Components.DaprDashboard, skipDaprDashboard),
                                CommandExists: func() bool </span><span class="cov0" title="0">{
                                        // Check if dapr dashboard command is available
                                        cmd := exec.Command("dapr", "dashboard", "--help")
                                        err := cmd.Run()
                                        return err == nil
                                }</span>(),
                                VerifyAvailable: func() bool <span class="cov0" title="0">{
                                        // Dashboard is available if the command exists
                                        return true
                                }</span>,
                                RequiresStartup: true, // We want the component system to handle it
                                IsBinary:        false,
                        },
                        {
                                Name:            "Temporal",
                                Command:         "temporal",
                                Args:            []string{"server", "start-dev"},
                                CheckCommand:    "temporal",
                                CheckArgs:       []string{"workflow", "list"},
                                RequiredFor:     []string{},
                                StartupDelay:    5 * time.Second, // Increased delay for Temporal to start fully
                                IsRequired:      getTemporalRequirement(configLoaded, config.Components.Temporal, skipTemporal),
                                CommandExists:   isCommandAvailable("temporal"),
                                VerifyAvailable: checkTemporalServerRunning,
                                RequiresStartup: true, // Temporal needs to be started
                                IsBinary:        false,
                        },
                }

                // First, check if required components are installed
                <span class="cov0" title="0">allInstalled := true
                for _, comp := range components </span><span class="cov0" title="0">{
                        if comp.IsRequired &amp;&amp; !comp.CommandExists </span><span class="cov0" title="0">{
                                fmt.Printf("❌ Required component '%s' is not installed or not in PATH.\n", comp.Name)
                                allInstalled = false
                        }</span> else<span class="cov0" title="0"> if verbose </span><span class="cov0" title="0">{
                                fmt.Printf("✅ Component '%s' is installed.\n", comp.Name)
                        }</span>
                }

                <span class="cov0" title="0">if !allInstalled </span><span class="cov0" title="0">{
                        fmt.Println("\nSome required components are missing. Please install them and try again.")
                        fmt.Println("Run 'devhelper-cli localenv init' to check required dependencies and create a configuration.")
                        os.Exit(1)
                }</span>

                // Next, check dependencies between components
                <span class="cov0" title="0">for i, comp := range components </span><span class="cov0" title="0">{
                        if !comp.IsRequired </span><span class="cov0" title="0">{
                                if verbose </span><span class="cov0" title="0">{
                                        fmt.Printf("⏭️  Skipping '%s' as it's not required.\n", comp.Name)
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }

                        // Check if any required components are missing
                        <span class="cov0" title="0">missingDeps := false
                        for _, dep := range comp.RequiredFor </span><span class="cov0" title="0">{
                                for _, depComp := range components </span><span class="cov0" title="0">{
                                        if depComp.Name == dep &amp;&amp; !depComp.CommandExists </span><span class="cov0" title="0">{
                                                fmt.Printf("❌ '%s' requires '%s', but it's not installed.\n", comp.Name, dep)
                                                missingDeps = true
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">if missingDeps </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Handle components differently based on RequiresStartup
                        <span class="cov0" title="0">if !comp.RequiresStartup </span><span class="cov0" title="0">{
                                // For components like Podman and Kind, just check if they're running
                                if comp.IsBinary </span><span class="cov0" title="0">{
                                        fmt.Printf("Checking if %s is available...\n", comp.Name)
                                        if comp.VerifyAvailable != nil &amp;&amp; comp.VerifyAvailable() </span><span class="cov0" title="0">{
                                                if comp.Name == "Podman" </span><span class="cov0" title="0">{
                                                        fmt.Printf("✅ %s is available and can run containers.\n", comp.Name)
                                                }</span> else<span class="cov0" title="0"> if comp.Name == "Kind" </span><span class="cov0" title="0">{
                                                        fmt.Printf("✅ %s is available and has clusters configured.\n", comp.Name)
                                                }</span> else<span class="cov0" title="0"> {
                                                        fmt.Printf("✅ %s is available.\n", comp.Name)
                                                }</span>
                                                <span class="cov0" title="0">components[i].IsRunning = true</span>
                                        } else<span class="cov0" title="0"> {
                                                if comp.Name == "Podman" </span><span class="cov0" title="0">{
                                                        fmt.Printf("❌ %s is not working properly.\n", comp.Name)
                                                        fmt.Println("   Make sure Podman is installed correctly and has proper permissions.")
                                                }</span> else<span class="cov0" title="0"> if comp.Name == "Kind" </span><span class="cov0" title="0">{
                                                        fmt.Printf("❌ %s does not have any clusters configured.\n", comp.Name)
                                                        fmt.Println("   Note: Kubernetes functionality is not required for local development.")
                                                }</span> else<span class="cov0" title="0"> {
                                                        fmt.Printf("❌ %s is not available.\n", comp.Name)
                                                }</span>
                                                <span class="cov0" title="0">allInstalled = false</span>
                                        }
                                } else<span class="cov0" title="0"> {
                                        // For non-binary components that still don't require startup
                                        fmt.Printf("Verifying %s is ready...\n", comp.Name)
                                        if comp.VerifyAvailable != nil &amp;&amp; comp.VerifyAvailable() </span><span class="cov0" title="0">{
                                                fmt.Printf("✅ %s is running and ready.\n", comp.Name)
                                                components[i].IsRunning = true
                                        }</span> else<span class="cov0" title="0"> {
                                                fmt.Printf("❌ %s is not running or not ready.\n", comp.Name)
                                                allInstalled = false
                                        }</span>
                                }
                                <span class="cov0" title="0">continue</span>
                        }

                        // For components that need to be started (Dapr, Temporal)
                        <span class="cov0" title="0">fmt.Printf("Starting %s...\n", comp.Name)

                        // Special handling for Dapr - check if it's already initialized
                        if comp.Name == "Dapr" </span><span class="cov0" title="0">{
                                // First check if Dapr is already running
                                if checkDaprRunning() </span><span class="cov0" title="0">{
                                        fmt.Println("✅ Dapr is already running, skipping initialization.")
                                        components[i].IsRunning = true
                                        continue</span>
                                }

                                // Run dapr init with Podman container runtime
                                <span class="cov0" title="0">initCmd := exec.Command("dapr", "init", "--container-runtime", "podman")
                                initOutput, err := initCmd.CombinedOutput()
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("❌ Failed to initialize Dapr: %v\n", err)
                                        if verbose </span><span class="cov0" title="0">{
                                                fmt.Printf("Output: %s\n", string(initOutput))
                                        }</span>
                                        <span class="cov0" title="0">continue</span>
                                }

                                <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                                        fmt.Printf("Dapr initialization output: %s\n", string(initOutput))
                                }</span>

                                // Wait a moment for Dapr to start
                                <span class="cov0" title="0">time.Sleep(2 * time.Second)

                                // Verify Dapr is running
                                if checkDaprRunning() </span><span class="cov0" title="0">{
                                        fmt.Println("✅ Dapr started successfully.")
                                        components[i].IsRunning = true
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Println("⚠️ Dapr initialization completed, but the runtime may not be fully ready.")
                                        components[i].IsRunning = true // Consider it running anyway
                                }</span>

                                <span class="cov0" title="0">continue</span>
                        }

                        // Special handling for Dapr Dashboard
                        <span class="cov0" title="0">if comp.Name == "DaprDashboard" </span><span class="cov0" title="0">{
                                // First check if the desired port is already in use
                                dashboardPort := config.Dapr.DashboardPort

                                // Get dashboard PID if it's running
                                dashboardPID := getDaprDashboardPID()

                                // Determine if a restart is required
                                restartRequired := forceRestart ||
                                        (configChanged &amp;&amp; dashboardPID != "" &amp;&amp;
                                                (configCache.DaprDashboardPort != dashboardPort))

                                // More robust process termination and port cleanup
                                if dashboardPID != "" </span><span class="cov0" title="0">{
                                        if restartRequired </span><span class="cov0" title="0">{
                                                fmt.Printf("Detected configuration change: Dashboard port changed (%d → %d)\n",
                                                        configCache.DaprDashboardPort, dashboardPort)
                                                fmt.Println("Stopping existing Dapr Dashboard...")

                                                // First try graceful termination with SIGTERM
                                                killCmd := exec.Command("kill", dashboardPID)
                                                if err := killCmd.Run(); err != nil </span><span class="cov0" title="0">{
                                                        fmt.Printf("Warning: Failed to stop Dapr Dashboard gracefully: %v\n", err)

                                                        // If graceful termination fails, try force kill (SIGKILL)
                                                        forceKillCmd := exec.Command("kill", "-9", dashboardPID)
                                                        if err := forceKillCmd.Run(); err != nil </span><span class="cov0" title="0">{
                                                                fmt.Printf("Error: Failed to force kill Dapr Dashboard: %v\n", err)
                                                        }</span>
                                                }

                                                // Give more time for the process to fully terminate
                                                <span class="cov0" title="0">time.Sleep(2 * time.Second)

                                                // Check if port is still in use by anything
                                                stillInUse := isPortInUse(dashboardPort)
                                                if stillInUse </span><span class="cov0" title="0">{
                                                        // Try to find any process using this port and kill it
                                                        cmd := exec.Command("lsof", "-i", fmt.Sprintf(":%d", dashboardPort), "-t")
                                                        output, err := cmd.Output()
                                                        if err == nil &amp;&amp; len(output) &gt; 0 </span><span class="cov0" title="0">{
                                                                pids := strings.Split(strings.TrimSpace(string(output)), "\n")
                                                                for _, pid := range pids </span><span class="cov0" title="0">{
                                                                        fmt.Printf("Forcefully terminating process %s that is still using port %d\n", pid, dashboardPort)
                                                                        exec.Command("kill", "-9", pid).Run()
                                                                }</span>
                                                                <span class="cov0" title="0">time.Sleep(1 * time.Second)</span>
                                                        }
                                                }

                                                // Final verification
                                                <span class="cov0" title="0">stillInUse = isPortInUse(dashboardPort)
                                                if stillInUse </span><span class="cov0" title="0">{
                                                        fmt.Printf("❌ Port %d is still in use after attempts to free it\n", dashboardPort)
                                                        fmt.Printf("   Try a different port or manually kill the process: lsof -i :%d -t | xargs kill -9\n", dashboardPort)
                                                        fmt.Println("   Updating localenv.yaml with a new port is recommended.")
                                                        fmt.Printf("   For example: dapr.dashboardPort: %d\n", dashboardPort+1)
                                                        continue</span>
                                                }
                                        } else<span class="cov0" title="0"> {
                                                // Dashboard is already running with current configuration
                                                dashboardURL := fmt.Sprintf("http://localhost:%d", dashboardPort)
                                                fmt.Printf("✅ Dapr Dashboard already running at %s\n", dashboardURL)
                                                components[i].IsRunning = true
                                                continue</span>
                                        }
                                }

                                // Check if the port is in use by something else
                                <span class="cov0" title="0">if isPortInUse(dashboardPort) </span><span class="cov0" title="0">{
                                        fmt.Printf("❌ Port %d is already in use by another process\n", dashboardPort)
                                        fmt.Printf("   Run 'lsof -i :%d' to see which process is using it\n", dashboardPort)
                                        fmt.Println("   Update the dashboardPort in localenv.yaml to a different value and try again.")
                                        fmt.Printf("   For example: dapr.dashboardPort: %d\n", dashboardPort+1)
                                        continue</span>
                                }

                                // For Dapr Dashboard, we need special handling to make sure it stays running
                                <span class="cov0" title="0">fmt.Println("Starting DaprDashboard in background mode...")

                                // Start the dashboard
                                dashboardStarted := tryStartDashboard(comp.Command, dashboardPort, nil)

                                if dashboardStarted </span><span class="cov0" title="0">{
                                        components[i].IsRunning = true
                                        dashboardURL := fmt.Sprintf("http://localhost:%d", dashboardPort)
                                        fmt.Printf("✅ Dapr Dashboard started at %s\n", dashboardURL)
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("❌ Failed to start Dapr Dashboard on port %d\n", dashboardPort)
                                        fmt.Println("   This could be because the port is already in use.")
                                        fmt.Printf("   You can check which process is using the port with: lsof -i :%d\n", dashboardPort)
                                        fmt.Println("   Update the dashboardPort in localenv.yaml to a different value and try again.")
                                        fmt.Printf("   For example: dapr.dashboardPort: %d\n", dashboardPort+1)
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }

                        // Special handling for Temporal server
                        <span class="cov0" title="0">if comp.Name == "Temporal" </span><span class="cov0" title="0">{
                                // Get Temporal configuration
                                temporalUIPort := config.Temporal.UIPort
                                temporalGRPCPort := config.Temporal.GRPCPort
                                temporalNamespace := config.Temporal.Namespace

                                // Check if Temporal is already running and if there are config changes
                                temporalRunning := checkTemporalServerRunning()

                                if temporalRunning </span><span class="cov0" title="0">{
                                        // Temporal is already running
                                        restartRequired := forceRestart || (configChanged &amp;&amp;
                                                (configCache.TemporalUIPort != temporalUIPort ||
                                                        configCache.TemporalGRPCPort != temporalGRPCPort ||
                                                        configCache.TemporalNamespace != temporalNamespace))

                                        if !restartRequired </span><span class="cov0" title="0">{
                                                fmt.Println("✅ Temporal is already running with current configuration, skipping startup.")
                                                components[i].IsRunning = true
                                                continue</span>
                                        }

                                        // If we need to restart, kill any existing Temporal server process
                                        <span class="cov0" title="0">fmt.Println("Detected configuration changes in Temporal settings:")
                                        for _, change := range changes </span><span class="cov0" title="0">{
                                                if strings.Contains(change, "Temporal") </span><span class="cov0" title="0">{
                                                        fmt.Printf("- %s\n", change)
                                                }</span>
                                        }

                                        <span class="cov0" title="0">fmt.Println("Stopping existing Temporal server...")
                                        // Find and kill the Temporal process
                                        found := false
                                        // First look for the main temporal server process
                                        cmd := exec.Command("ps", "-ef")
                                        output, err := cmd.CombinedOutput()
                                        if err == nil </span><span class="cov0" title="0">{
                                                outputLines := strings.Split(string(output), "\n")
                                                for _, line := range outputLines </span><span class="cov0" title="0">{
                                                        if strings.Contains(line, "temporal server start-dev") &amp;&amp; !strings.Contains(line, "grep") </span><span class="cov0" title="0">{
                                                                fields := strings.Fields(line)
                                                                if len(fields) &gt;= 2 </span><span class="cov0" title="0">{
                                                                        pid := fields[1]
                                                                        fmt.Printf("Stopping Temporal server process (PID: %s)...\n", pid)
                                                                        killCmd := exec.Command("kill", pid)
                                                                        killCmd.Run()
                                                                        found = true
                                                                }</span>
                                                        }
                                                }
                                        }

                                        // Also check for any processes on the Temporal ports
                                        <span class="cov0" title="0">if !found || isPortInUse(temporalUIPort) || isPortInUse(temporalGRPCPort) </span><span class="cov0" title="0">{
                                                fmt.Println("Looking for processes using Temporal ports...")

                                                // Check UI port
                                                uiPortCmd := exec.Command("lsof", "-i", fmt.Sprintf(":%d", temporalUIPort), "-t")
                                                uiPortOutput, _ := uiPortCmd.Output()
                                                if len(uiPortOutput) &gt; 0 </span><span class="cov0" title="0">{
                                                        pids := strings.Split(strings.TrimSpace(string(uiPortOutput)), "\n")
                                                        for _, pid := range pids </span><span class="cov0" title="0">{
                                                                fmt.Printf("Forcefully terminating process %s using Temporal UI port %d\n", pid, temporalUIPort)
                                                                exec.Command("kill", "-9", pid).Run()
                                                        }</span>
                                                }

                                                // Check GRPC port
                                                <span class="cov0" title="0">grpcPortCmd := exec.Command("lsof", "-i", fmt.Sprintf(":%d", temporalGRPCPort), "-t")
                                                grpcPortOutput, _ := grpcPortCmd.Output()
                                                if len(grpcPortOutput) &gt; 0 </span><span class="cov0" title="0">{
                                                        pids := strings.Split(strings.TrimSpace(string(grpcPortOutput)), "\n")
                                                        for _, pid := range pids </span><span class="cov0" title="0">{
                                                                fmt.Printf("Forcefully terminating process %s using Temporal GRPC port %d\n", pid, temporalGRPCPort)
                                                                exec.Command("kill", "-9", pid).Run()
                                                        }</span>
                                                }
                                        }

                                        // Give more time for processes to fully terminate
                                        <span class="cov0" title="0">time.Sleep(3 * time.Second)

                                        // Final verification
                                        if isPortInUse(temporalUIPort) </span><span class="cov0" title="0">{
                                                fmt.Printf("❌ Temporal UI port %d is still in use after attempts to free it\n", temporalUIPort)
                                                fmt.Printf("   Try manually killing the process: lsof -i :%d -t | xargs kill -9\n", temporalUIPort)
                                                continue</span>
                                        }

                                        <span class="cov0" title="0">if isPortInUse(temporalGRPCPort) </span><span class="cov0" title="0">{
                                                fmt.Printf("❌ Temporal GRPC port %d is still in use after attempts to free it\n", temporalGRPCPort)
                                                fmt.Printf("   Try manually killing the process: lsof -i :%d -t | xargs kill -9\n", temporalGRPCPort)
                                                continue</span>
                                        }
                                } else<span class="cov0" title="0"> {
                                        // Temporal is not running, check if ports are available
                                        if isPortInUse(temporalUIPort) </span><span class="cov0" title="0">{
                                                fmt.Printf("❌ Temporal UI port %d is already in use by another process\n", temporalUIPort)
                                                fmt.Printf("   Run 'lsof -i :%d' to see which process is using it\n", temporalUIPort)
                                                fmt.Println("   Update the UIPort in localenv.yaml to a different value and try again.")
                                                continue</span>
                                        }

                                        <span class="cov0" title="0">if isPortInUse(temporalGRPCPort) </span><span class="cov0" title="0">{
                                                fmt.Printf("❌ Temporal GRPC port %d is already in use by another process\n", temporalGRPCPort)
                                                fmt.Printf("   Run 'lsof -i :%d' to see which process is using it\n", temporalGRPCPort)
                                                fmt.Println("   Update the GRPCPort in localenv.yaml to a different value and try again.")
                                                continue</span>
                                        }
                                }

                                // Start Temporal server in background
                                <span class="cov0" title="0">fmt.Println("Starting Temporal server in background mode...")

                                // Prepare command with namespace flag if configured
                                var temporalCmd *exec.Cmd
                                if configLoaded &amp;&amp; config.Components.Temporal &amp;&amp; temporalNamespace != "" &amp;&amp; temporalNamespace != "default" </span><span class="cov0" title="0">{
                                        fmt.Printf("Configuring Temporal with namespace: %s\n", temporalNamespace)
                                        // Use a more efficient approach - create the namespace first if needed, then start server
                                        // This avoids potential issues with the namespace not being created properly during startup

                                        // First check if the namespace exists
                                        namespaceCheckCmd := exec.Command("temporal", "operator", "namespace", "describe", temporalNamespace)
                                        if err := namespaceCheckCmd.Run(); err != nil </span><span class="cov0" title="0">{
                                                // Namespace doesn't exist, create it first
                                                fmt.Printf("Creating Temporal namespace '%s'...\n", temporalNamespace)
                                                createCmd := exec.Command("temporal", "operator", "namespace", "create", temporalNamespace)
                                                if output, err := createCmd.CombinedOutput(); err != nil </span><span class="cov0" title="0">{
                                                        fmt.Printf("❌ Failed to create namespace: %v\n", err)
                                                        if verbose </span><span class="cov0" title="0">{
                                                                fmt.Printf("Output: %s\n", string(output))
                                                        }</span>
                                                } else<span class="cov0" title="0"> {
                                                        fmt.Printf("✅ Created Temporal namespace '%s'\n", temporalNamespace)
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                fmt.Printf("✅ Temporal namespace '%s' already exists\n", temporalNamespace)
                                        }</span>

                                        // Start the server normally
                                        <span class="cov0" title="0">temporalCmd = exec.Command("temporal", "server", "start-dev")</span>
                                } else<span class="cov0" title="0"> {
                                        temporalCmd = exec.Command("temporal", "server", "start-dev")
                                }</span>

                                // Create logs directory if it doesn't exist
                                <span class="cov0" title="0">logsDir := filepath.Join(os.Getenv("HOME"), ".logs", "devhelper-cli")
                                if _, err := os.Stat(logsDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                                        os.MkdirAll(logsDir, 0755)
                                }</span>

                                <span class="cov0" title="0">logFilePath := filepath.Join(logsDir, "temporal-server.log")

                                // Configure logs based on stream-logs flag
                                if streamLogs </span><span class="cov0" title="0">{
                                        // In streaming mode, we'll use a MultiWriter to write to both terminal and file
                                        logFile, err := os.OpenFile(
                                                logFilePath,
                                                os.O_CREATE|os.O_WRONLY|os.O_APPEND,
                                                0644,
                                        )

                                        if err == nil </span><span class="cov0" title="0">{
                                                defer logFile.Close()

                                                // Create a MultiWriter that sends output to both the terminal and log file
                                                multiWriter := io.MultiWriter(os.Stdout, logFile)
                                                temporalCmd.Stdout = multiWriter
                                                temporalCmd.Stderr = multiWriter

                                                fmt.Println("📃 Streaming Temporal server logs to terminal and writing to log file...")
                                                fmt.Printf("📂 Log file: %s\n", logFilePath)
                                        }</span> else<span class="cov0" title="0"> {
                                                // Fallback to just terminal if can't create log file
                                                fmt.Printf("⚠️ Warning: Could not create log file: %v\n", err)
                                                fmt.Println("📃 Streaming Temporal server logs to terminal only...")
                                                temporalCmd.Stdout = os.Stdout
                                                temporalCmd.Stderr = os.Stderr
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        // Standard non-streaming mode, just write to log file
                                        logFile, err := os.OpenFile(
                                                logFilePath,
                                                os.O_CREATE|os.O_WRONLY|os.O_APPEND,
                                                0644,
                                        )

                                        if err == nil </span><span class="cov0" title="0">{
                                                defer logFile.Close()
                                                temporalCmd.Stdout = logFile
                                                temporalCmd.Stderr = logFile
                                                fmt.Printf("📂 Temporal server logs will be written to %s\n", logFilePath)
                                                fmt.Println("💡 Use --stream-logs flag to see logs in terminal")
                                        }</span> else<span class="cov0" title="0"> {
                                                // Fallback to null device if can't create log file
                                                fmt.Printf("⚠️ Warning: Could not create log file: %v\n", err)
                                                devNull, _ := os.OpenFile(os.DevNull, os.O_WRONLY, 0)
                                                temporalCmd.Stdout = devNull
                                                temporalCmd.Stderr = devNull
                                        }</span>
                                }

                                // Start Temporal server in background
                                <span class="cov0" title="0">if err := temporalCmd.Start(); err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("❌ Failed to start Temporal server: %v\n", err)
                                        continue</span>
                                }

                                // Wait for Temporal to start up
                                <span class="cov0" title="0">fmt.Println("⏳ Waiting for Temporal server to start...")
                                time.Sleep(5 * time.Second)

                                // Verify Temporal is running with increased retries and timeout
                                retries := 5                  // Increased from 3
                                retryDelay := 3 * time.Second // Increased from 2
                                temporalStarted := false

                                for retry := 0; retry &lt; retries; retry++ </span><span class="cov0" title="0">{
                                        if checkTemporalServerRunning() </span><span class="cov0" title="0">{
                                                fmt.Println("✅ Temporal server started successfully.")
                                                components[i].IsRunning = true
                                                temporalStarted = true
                                                break</span>
                                        }

                                        <span class="cov0" title="0">if retry &lt; retries-1 </span><span class="cov0" title="0">{
                                                fmt.Println("Waiting for Temporal server to become available...")
                                                time.Sleep(retryDelay)
                                        }</span> else<span class="cov0" title="0"> {
                                                fmt.Println("❌ Temporal server did not start properly.")
                                                fmt.Println("   Check the logs at " + filepath.Join(logsDir, "temporal-server.log") + " for details.")
                                        }</span>
                                }

                                <span class="cov0" title="0">if !temporalStarted </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                        }
                }

                // Check if all components are running
                <span class="cov0" title="0">for _, comp := range components </span><span class="cov0" title="0">{
                        if comp.IsRequired &amp;&amp; !comp.IsRunning </span><span class="cov0" title="0">{
                                fmt.Printf("❌ %s is not running. Please check its logs for errors.\n", comp.Name)
                                allInstalled = false
                        }</span>
                }

                <span class="cov0" title="0">if !allInstalled </span><span class="cov0" title="0">{
                        fmt.Println("\nSome components failed to start. Please check the logs for errors.")
                        os.Exit(1)
                }</span>

                // Save current configuration for future comparison
                <span class="cov0" title="0">saveConfigCache(newCache)

                fmt.Println("\nAll required components are running successfully!")</span>
        },
}

func init() <span class="cov8" title="1">{
        localenvCmd.AddCommand(startCmd)
        startCmd.Flags().BoolP("verbose", "v", false, "Enable verbose output")
        startCmd.Flags().Bool("skip-dapr", false, "Skip starting Dapr")
        startCmd.Flags().Bool("skip-temporal", false, "Skip starting Temporal")
        startCmd.Flags().Bool("skip-dapr-dashboard", false, "Skip starting Dapr Dashboard")
        startCmd.Flags().Bool("force-restart", false, "Force restart of components even if already running")
        startCmd.Flags().StringP("config", "c", "", "Path to localenv configuration file")
        startCmd.Flags().Bool("stream-logs", false, "Stream Temporal server logs to terminal")
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright © 2023 ShieldDev

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package cmd

import (
        "fmt"
        "os"
        "os/exec"
        "strings"
        "time"

        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"
)

// stopCmd represents the stop command
var stopCmd = &amp;cobra.Command{
        Use:   "stop",
        Short: "Stop local development environment",
        Long: `Stop the local development environment components.

This command will stop all running components in the local development
environment, including:
- Dapr runtime
- Temporal server
- Related processes`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Println("Stopping local development environment...")

                verbose, _ := cmd.Flags().GetBool("verbose")
                skipDapr, _ := cmd.Flags().GetBool("skip-dapr")
                skipTemporal, _ := cmd.Flags().GetBool("skip-temporal")
                skipDaprDashboard, _ := cmd.Flags().GetBool("skip-dapr-dashboard")
                force, _ := cmd.Flags().GetBool("force")
                configPath, _ := cmd.Flags().GetString("config")

                // If no config path is provided, look for localenv.yaml in current directory
                if configPath == "" </span><span class="cov0" title="0">{
                        configPath = "localenv.yaml"
                }</span>

                // Load configuration if available
                <span class="cov0" title="0">config := LocalEnvConfig{}
                configLoaded := false

                // Check if config file exists
                if _, err := os.Stat(configPath); err == nil </span><span class="cov0" title="0">{
                        // Read and parse configuration
                        configData, err := os.ReadFile(configPath)
                        if err == nil </span><span class="cov0" title="0">{
                                err = yaml.Unmarshal(configData, &amp;config)
                                if err == nil </span><span class="cov0" title="0">{
                                        configLoaded = true
                                        fmt.Printf("✅ Loaded configuration from %s\n", configPath)
                                }</span> else<span class="cov0" title="0"> if verbose </span><span class="cov0" title="0">{
                                        fmt.Printf("⚠️ Failed to parse configuration: %v\n", err)
                                }</span>
                        } else<span class="cov0" title="0"> if verbose </span><span class="cov0" title="0">{
                                fmt.Printf("⚠️ Failed to read configuration: %v\n", err)
                        }</span>
                } else<span class="cov0" title="0"> if verbose </span><span class="cov0" title="0">{
                        fmt.Printf("⚠️ Configuration file not found at %s\n", configPath)
                        fmt.Println("   Run 'devhelper-cli localenv init' to create a configuration")
                }</span>

                // Determine which components to stop based on config and flags
                <span class="cov0" title="0">stopDapr := !skipDapr
                stopTemporal := !skipTemporal
                stopDaprDashboard := !skipDaprDashboard

                if configLoaded </span><span class="cov0" title="0">{
                        // If config is loaded, only stop enabled components (unless explicitly skipped)
                        if !config.Components.Dapr </span><span class="cov0" title="0">{
                                stopDapr = false
                        }</span>
                        <span class="cov0" title="0">if !config.Components.Temporal </span><span class="cov0" title="0">{
                                stopTemporal = false
                        }</span>
                        <span class="cov0" title="0">if !config.Components.DaprDashboard </span><span class="cov0" title="0">{
                                stopDaprDashboard = false
                        }</span>
                }

                <span class="cov0" title="0">stoppedCount := 0

                // Stop Dapr Dashboard by finding and killing its process
                if stopDaprDashboard &amp;&amp; isCommandAvailable("dapr") &amp;&amp; isDaprDashboardAvailable() </span><span class="cov0" title="0">{
                        fmt.Println("Stopping Dapr Dashboard...")

                        // Try multiple methods to find dashboard processes
                        dashboardPids := []string{}
                        found := false

                        // Method 1: Try using pgrep first (more reliable on macOS and Linux)
                        pgrepCmd := exec.Command("pgrep", "-f", "dapr dashboard")
                        pgrepOutput, pgrepErr := pgrepCmd.Output()

                        if pgrepErr == nil &amp;&amp; len(pgrepOutput) &gt; 0 </span><span class="cov0" title="0">{
                                // Process found with pgrep
                                pids := strings.Split(strings.TrimSpace(string(pgrepOutput)), "\n")
                                for _, pid := range pids </span><span class="cov0" title="0">{
                                        if pid != "" </span><span class="cov0" title="0">{
                                                dashboardPids = append(dashboardPids, pid)
                                                found = true
                                        }</span>
                                }
                        }

                        // Method 2: Try using ps (works on most Unix systems)
                        <span class="cov0" title="0">psCmd := exec.Command("ps", "-ef")
                        psOutput, psErr := psCmd.Output()

                        if psErr == nil </span><span class="cov0" title="0">{
                                lines := strings.Split(string(psOutput), "\n")
                                for _, line := range lines </span><span class="cov0" title="0">{
                                        if strings.Contains(line, "dapr dashboard") &amp;&amp; !strings.Contains(line, "grep") </span><span class="cov0" title="0">{
                                                // Parse the line to extract PID
                                                fields := strings.Fields(line)
                                                if len(fields) &gt; 1 </span><span class="cov0" title="0">{
                                                        // Check if we already have this PID
                                                        pidExists := false
                                                        for _, existingPid := range dashboardPids </span><span class="cov0" title="0">{
                                                                if existingPid == fields[1] </span><span class="cov0" title="0">{
                                                                        pidExists = true
                                                                        break</span>
                                                                }
                                                        }
                                                        <span class="cov0" title="0">if !pidExists </span><span class="cov0" title="0">{
                                                                dashboardPids = append(dashboardPids, fields[1])
                                                                found = true
                                                        }</span>
                                                }
                                        }
                                }
                        }

                        // Method 3: Try using lsof to find processes using the dashboard port
                        <span class="cov0" title="0">if configLoaded &amp;&amp; config.Dapr.DashboardPort &gt; 0 </span><span class="cov0" title="0">{
                                portStr := fmt.Sprintf("%d", config.Dapr.DashboardPort)
                                lsofCmd := exec.Command("lsof", "-i", fmt.Sprintf(":%s", portStr))
                                lsofOutput, lsofErr := lsofCmd.Output()

                                if lsofErr == nil &amp;&amp; len(lsofOutput) &gt; 0 </span><span class="cov0" title="0">{
                                        lines := strings.Split(string(lsofOutput), "\n")
                                        for _, line := range lines </span><span class="cov0" title="0">{
                                                if strings.Contains(line, "LISTEN") </span><span class="cov0" title="0">{
                                                        fields := strings.Fields(line)
                                                        if len(fields) &gt; 1 </span><span class="cov0" title="0">{
                                                                pidExists := false
                                                                for _, existingPid := range dashboardPids </span><span class="cov0" title="0">{
                                                                        if existingPid == fields[1] </span><span class="cov0" title="0">{
                                                                                pidExists = true
                                                                                break</span>
                                                                        }
                                                                }
                                                                <span class="cov0" title="0">if !pidExists </span><span class="cov0" title="0">{
                                                                        dashboardPids = append(dashboardPids, fields[1])
                                                                        found = true
                                                                }</span>
                                                        }
                                                }
                                        }
                                }
                        }

                        <span class="cov0" title="0">if found &amp;&amp; len(dashboardPids) &gt; 0 </span><span class="cov0" title="0">{
                                allKilled := true

                                if verbose </span><span class="cov0" title="0">{
                                        fmt.Printf("Found %d Dapr Dashboard processes: %s\n", len(dashboardPids), strings.Join(dashboardPids, ", "))
                                }</span>

                                <span class="cov0" title="0">for _, pid := range dashboardPids </span><span class="cov0" title="0">{
                                        // First try a gentle termination with SIGTERM
                                        killCmd := exec.Command("kill", pid)
                                        killErr := killCmd.Run()

                                        if killErr != nil &amp;&amp; force </span><span class="cov0" title="0">{
                                                // If that fails and we're forcing, try SIGKILL
                                                killCmd = exec.Command("kill", "-9", pid)
                                                killErr = killCmd.Run()
                                        }</span>

                                        <span class="cov0" title="0">if killErr != nil </span><span class="cov0" title="0">{
                                                allKilled = false
                                                if verbose </span><span class="cov0" title="0">{
                                                        fmt.Printf("Failed to kill Dapr Dashboard process %s: %v\n", pid, killErr)
                                                }</span>
                                        } else<span class="cov0" title="0"> if verbose </span><span class="cov0" title="0">{
                                                fmt.Printf("Killed Dapr Dashboard process with PID %s\n", pid)
                                        }</span>
                                }

                                <span class="cov0" title="0">if allKilled </span><span class="cov0" title="0">{
                                        fmt.Println("✅ Dapr Dashboard stopped successfully.")
                                        stoppedCount++
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Println("❌ Failed to stop some Dapr Dashboard processes.")
                                        if force </span><span class="cov0" title="0">{
                                                fmt.Println("   Continuing due to --force flag.")
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> {
                                if verbose </span><span class="cov0" title="0">{
                                        fmt.Println("No running Dapr Dashboard processes found.")
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Println("❌ No running Dapr Dashboard processes found.")
                                }</span>
                        }
                } else<span class="cov0" title="0"> if !stopDaprDashboard &amp;&amp; verbose </span><span class="cov0" title="0">{
                        fmt.Println("⏭️  Skipping Dapr Dashboard (disabled in config or by flag).")
                }</span>

                // Stop Temporal server by finding and killing its process
                <span class="cov0" title="0">if stopTemporal &amp;&amp; isCommandAvailable("temporal") </span><span class="cov0" title="0">{
                        fmt.Println("Stopping Temporal...")

                        // Get Temporal port configuration
                        temporalUIPort := 8233   // Default UI port
                        temporalGRPCPort := 7233 // Default GRPC port

                        // Load port values from config if available
                        if configLoaded </span><span class="cov0" title="0">{
                                if config.Temporal.UIPort != 0 </span><span class="cov0" title="0">{
                                        temporalUIPort = config.Temporal.UIPort
                                }</span>
                                <span class="cov0" title="0">if config.Temporal.GRPCPort != 0 </span><span class="cov0" title="0">{
                                        temporalGRPCPort = config.Temporal.GRPCPort
                                }</span>
                        }

                        // Keep track of whether we successfully stopped the server
                        <span class="cov0" title="0">temporalStopped := false

                        // Try multiple methods to find and stop Temporal processes

                        // Method 1: Find the Temporal server process by name
                        findCmd := exec.Command("pgrep", "-f", "temporal server start-dev")
                        output, err := findCmd.Output()

                        if err == nil &amp;&amp; len(output) &gt; 0 </span><span class="cov0" title="0">{
                                // Process found, try to kill it
                                pids := strings.Split(strings.TrimSpace(string(output)), "\n")
                                allKilled := true

                                if verbose </span><span class="cov0" title="0">{
                                        fmt.Printf("Found %d Temporal server processes: %s\n", len(pids), strings.Join(pids, ", "))
                                }</span>

                                <span class="cov0" title="0">for _, pid := range pids </span><span class="cov0" title="0">{
                                        fmt.Printf("Stopping Temporal server process (PID: %s)...\n", pid)

                                        // First try graceful termination with SIGTERM
                                        killCmd := exec.Command("kill", pid)
                                        killErr := killCmd.Run()

                                        if killErr != nil &amp;&amp; force </span><span class="cov0" title="0">{
                                                // If that fails and force flag is set, try SIGKILL
                                                fmt.Println("  Attempting forceful termination with SIGKILL...")
                                                killCmd = exec.Command("kill", "-9", pid)
                                                killErr = killCmd.Run()
                                        }</span>

                                        <span class="cov0" title="0">if killErr != nil </span><span class="cov0" title="0">{
                                                allKilled = false
                                                if verbose </span><span class="cov0" title="0">{
                                                        fmt.Printf("Failed to kill Temporal process %s: %v\n", pid, killErr)
                                                }</span>
                                        } else<span class="cov0" title="0"> if verbose </span><span class="cov0" title="0">{
                                                fmt.Printf("Killed Temporal process with PID %s\n", pid)
                                        }</span>
                                }

                                <span class="cov0" title="0">if allKilled </span><span class="cov0" title="0">{
                                        temporalStopped = true
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Println("❌ Failed to stop some Temporal processes.")
                                        if force </span><span class="cov0" title="0">{
                                                fmt.Println("   Continuing due to --force flag.")
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> if verbose </span><span class="cov0" title="0">{
                                fmt.Println("No Temporal server processes found by name search.")
                        }</span>

                        // Method 2: Find processes using the Temporal UI port
                        <span class="cov0" title="0">uiPortCmd := exec.Command("lsof", "-i", fmt.Sprintf(":%d", temporalUIPort), "-t")
                        uiPortOutput, _ := uiPortCmd.Output()

                        if len(uiPortOutput) &gt; 0 </span><span class="cov0" title="0">{
                                pids := strings.Split(strings.TrimSpace(string(uiPortOutput)), "\n")

                                if verbose </span><span class="cov0" title="0">{
                                        fmt.Printf("Found %d processes using Temporal UI port %d: %s\n",
                                                len(pids), temporalUIPort, strings.Join(pids, ", "))
                                }</span>

                                <span class="cov0" title="0">for _, pid := range pids </span><span class="cov0" title="0">{
                                        fmt.Printf("Stopping process using Temporal UI port %d (PID: %s)...\n", temporalUIPort, pid)

                                        // Try to kill the process, with force if requested
                                        killCmd := exec.Command("kill", pid)
                                        killErr := killCmd.Run()

                                        if killErr != nil &amp;&amp; force </span><span class="cov0" title="0">{
                                                killCmd = exec.Command("kill", "-9", pid)
                                                killErr = killCmd.Run()
                                        }</span>

                                        <span class="cov0" title="0">if killErr == nil </span><span class="cov0" title="0">{
                                                temporalStopped = true
                                        }</span>
                                }
                        }

                        // Method 3: Find processes using the Temporal GRPC port
                        <span class="cov0" title="0">grpcPortCmd := exec.Command("lsof", "-i", fmt.Sprintf(":%d", temporalGRPCPort), "-t")
                        grpcPortOutput, _ := grpcPortCmd.Output()

                        if len(grpcPortOutput) &gt; 0 </span><span class="cov0" title="0">{
                                pids := strings.Split(strings.TrimSpace(string(grpcPortOutput)), "\n")

                                if verbose </span><span class="cov0" title="0">{
                                        fmt.Printf("Found %d processes using Temporal GRPC port %d: %s\n",
                                                len(pids), temporalGRPCPort, strings.Join(pids, ", "))
                                }</span>

                                <span class="cov0" title="0">for _, pid := range pids </span><span class="cov0" title="0">{
                                        fmt.Printf("Stopping process using Temporal GRPC port %d (PID: %s)...\n", temporalGRPCPort, pid)

                                        // Try to kill the process, with force if requested
                                        killCmd := exec.Command("kill", pid)
                                        killErr := killCmd.Run()

                                        if killErr != nil &amp;&amp; force </span><span class="cov0" title="0">{
                                                killCmd = exec.Command("kill", "-9", pid)
                                                killErr = killCmd.Run()
                                        }</span>

                                        <span class="cov0" title="0">if killErr == nil </span><span class="cov0" title="0">{
                                                temporalStopped = true
                                        }</span>
                                }
                        }

                        // Verify ports are actually free
                        <span class="cov0" title="0">time.Sleep(2 * time.Second)
                        uiPortInUse := isPortInUse(temporalUIPort)
                        grpcPortInUse := isPortInUse(temporalGRPCPort)

                        if uiPortInUse || grpcPortInUse </span><span class="cov0" title="0">{
                                if uiPortInUse </span><span class="cov0" title="0">{
                                        fmt.Printf("❌ Temporal UI port %d is still in use\n", temporalUIPort)
                                        fmt.Printf("   Try manually killing the process: lsof -i :%d -t | xargs kill -9\n", temporalUIPort)
                                }</span>

                                <span class="cov0" title="0">if grpcPortInUse </span><span class="cov0" title="0">{
                                        fmt.Printf("❌ Temporal GRPC port %d is still in use\n", temporalGRPCPort)
                                        fmt.Printf("   Try manually killing the process: lsof -i :%d -t | xargs kill -9\n", temporalGRPCPort)
                                }</span>

                                <span class="cov0" title="0">if force </span><span class="cov0" title="0">{
                                        fmt.Println("   Continuing due to --force flag.")
                                }</span>
                        }

                        <span class="cov0" title="0">if temporalStopped </span><span class="cov0" title="0">{
                                fmt.Println("✅ Temporal stopped successfully.")
                                stoppedCount++
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println("❌ Failed to find or stop Temporal server processes.")
                                if verbose </span><span class="cov0" title="0">{
                                        fmt.Println("   If Temporal is still running, you can try:")
                                        fmt.Printf("   lsof -i :%d -t | xargs kill -9\n", temporalUIPort)
                                        fmt.Printf("   lsof -i :%d -t | xargs kill -9\n", temporalGRPCPort)
                                }</span>
                        }
                } else<span class="cov0" title="0"> if !stopTemporal &amp;&amp; verbose </span><span class="cov0" title="0">{
                        fmt.Println("⏭️  Skipping Temporal (disabled in config or by flag).")
                }</span>

                // Stop Dapr runtime
                <span class="cov0" title="0">if stopDapr &amp;&amp; isCommandAvailable("dapr") </span><span class="cov0" title="0">{
                        fmt.Println("Stopping Dapr...")

                        // Check if any Dapr apps are running and stop them
                        listCmd := exec.Command("dapr", "list")
                        listOutput, _ := listCmd.Output()

                        if len(listOutput) &gt; 0 &amp;&amp; !strings.Contains(string(listOutput), "No Dapr instances found") </span><span class="cov0" title="0">{
                                if verbose </span><span class="cov0" title="0">{
                                        fmt.Println("Stopping running Dapr applications...")
                                        fmt.Println(string(listOutput))
                                }</span>

                                // Stop each running Dapr app
                                // This command would need to parse the output and stop each app by ID
                                // For simplicity, we'll just uninstall which should stop everything
                        }

                        // Run the dapr uninstall command
                        <span class="cov0" title="0">uninstallCmd := exec.Command("dapr", "uninstall", "--all", "--container-runtime", "podman")
                        uninstallOutput, err := uninstallCmd.CombinedOutput()
                        outputStr := string(uninstallOutput)

                        // Check for success despite Docker-related errors
                        success := err == nil ||
                                (strings.Contains(outputStr, "Error removing Dapr") &amp;&amp;
                                        strings.Contains(outputStr, "docker") &amp;&amp;
                                        isCommandAvailable("podman"))

                        if !success </span><span class="cov0" title="0">{
                                fmt.Printf("❌ Failed to stop Dapr: %v\n", err)
                                if verbose </span><span class="cov0" title="0">{
                                        fmt.Printf("Output: %s\n", outputStr)
                                }</span>
                                <span class="cov0" title="0">if !force </span><span class="cov0" title="0">{
                                        // Only exit if force flag is not set
                                        if stoppedCount == 0 </span><span class="cov0" title="0">{
                                                fmt.Println("\n⚠️  No components were stopped successfully.")
                                        }</span> else<span class="cov0" title="0"> {
                                                fmt.Println("\n⚠️  Some components were not stopped properly.")
                                        }</span>
                                        <span class="cov0" title="0">return</span>
                                }
                        } else<span class="cov0" title="0"> {
                                fmt.Println("✅ Dapr stopped successfully.")

                                // If there were Docker-related warnings but we're using Podman, add a clarification
                                if strings.Contains(outputStr, "docker") &amp;&amp; isCommandAvailable("podman") </span><span class="cov0" title="0">{
                                        fmt.Println("   (Docker-related warnings can be ignored when using Podman)")
                                }</span>

                                <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                                        fmt.Printf("Output: %s\n", outputStr)
                                }</span>
                                <span class="cov0" title="0">stoppedCount++</span>
                        }
                } else<span class="cov0" title="0"> if !stopDapr &amp;&amp; verbose </span><span class="cov0" title="0">{
                        fmt.Println("⏭️  Skipping Dapr (disabled in config or by flag).")
                }</span>

                <span class="cov0" title="0">if stoppedCount &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Println("\n✅ Local development environment has been stopped.")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("\n⚠️  No components were stopped. They may not be running or were not found.")
                }</span>
        },
}

func init() <span class="cov8" title="1">{
        localenvCmd.AddCommand(stopCmd)

        // Add flags specific to the stop command
        stopCmd.Flags().Bool("skip-dapr", false, "Skip stopping Dapr runtime")
        stopCmd.Flags().Bool("skip-temporal", false, "Skip stopping Temporal server")
        stopCmd.Flags().Bool("skip-dapr-dashboard", false, "Skip stopping Dapr Dashboard")
        stopCmd.Flags().Bool("force", false, "Force stop all components even if errors occur")
        stopCmd.Flags().StringP("config", "c", "", "Path to environment configuration file (default: localenv.yaml)")
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
Copyright © 2023 ShieldDev

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package cmd

import (
        "fmt"

        "github.com/spf13/cobra"
)

// version variables - these can be set during build time with ldflags
var (
        Version   = "0.1.0"
        BuildDate = "unknown"
        Commit    = "unknown"
)

// versionCmd represents the version command
var versionCmd = &amp;cobra.Command{
        Use:   "version",
        Short: "Print the version number of devhelper-cli",
        Long:  `All software has versions. This is devhelper-cli's.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Printf("devhelper-cli version: %s\n", Version)
                fmt.Printf("Build Date: %s\n", BuildDate)
                fmt.Printf("Git Commit: %s\n", Commit)
        }</span>,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(versionCmd)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package test

import (
        "bytes"
        "io"
        "os"
        "os/exec"
        "testing"

        "github.com/spf13/cobra"
)

// CommandRunner allows testing of Cobra commands
type CommandRunner struct {
        t         *testing.T
        cmd       *cobra.Command
        args      []string
        outputBuf *bytes.Buffer
        errorBuf  *bytes.Buffer
}

// NewCommandRunner creates a new command runner for testing
func NewCommandRunner(t *testing.T, cmd *cobra.Command) *CommandRunner <span class="cov0" title="0">{
        return &amp;CommandRunner{
                t:         t,
                cmd:       cmd,
                outputBuf: new(bytes.Buffer),
                errorBuf:  new(bytes.Buffer),
        }
}</span>

// WithArgs adds arguments to the command
func (r *CommandRunner) WithArgs(args ...string) *CommandRunner <span class="cov0" title="0">{
        r.args = args
        return r
}</span>

// Run executes the command and captures output
func (r *CommandRunner) Run() (string, string, error) <span class="cov0" title="0">{
        // Clone the command to avoid modifying the original
        cmd := &amp;cobra.Command{}
        *cmd = *r.cmd

        // Redirect to our buffers
        cmd.SetOut(r.outputBuf)
        cmd.SetErr(r.errorBuf)

        // Reset buffers
        r.outputBuf.Reset()
        r.errorBuf.Reset()

        // Set command args
        cmd.SetArgs(r.args)

        // Run the command
        err := cmd.Execute()

        // Return the output and error
        return r.outputBuf.String(), r.errorBuf.String(), err
}</span>

// ExecutableTester is used to test the actual executable
type ExecutableTester struct {
        t            *testing.T
        execPath     string
        envVars      []string
        stdoutBuffer *bytes.Buffer
        stderrBuffer *bytes.Buffer
}

// NewExecutableTester creates a new tester for CLI executables
func NewExecutableTester(t *testing.T, execPath string) *ExecutableTester <span class="cov0" title="0">{
        return &amp;ExecutableTester{
                t:            t,
                execPath:     execPath,
                stdoutBuffer: new(bytes.Buffer),
                stderrBuffer: new(bytes.Buffer),
        }
}</span>

// WithEnv adds environment variables to the command
func (e *ExecutableTester) WithEnv(envVars []string) *ExecutableTester <span class="cov0" title="0">{
        e.envVars = envVars
        return e
}</span>

// Run executes the CLI with given arguments
func (e *ExecutableTester) Run(args ...string) (string, string, error) <span class="cov0" title="0">{
        cmd := exec.Command(e.execPath, args...)

        // Set environment variables
        if len(e.envVars) &gt; 0 </span><span class="cov0" title="0">{
                cmd.Env = append(os.Environ(), e.envVars...)
        }</span>

        // Clear buffers
        <span class="cov0" title="0">e.stdoutBuffer.Reset()
        e.stderrBuffer.Reset()

        // Capture stdout and stderr
        cmd.Stdout = e.stdoutBuffer
        cmd.Stderr = e.stderrBuffer

        // Run command
        err := cmd.Run()

        return e.stdoutBuffer.String(), e.stderrBuffer.String(), err</span>
}

// CommandAvailabilityChecker defines a function type for checking if commands are available
type CommandAvailabilityChecker func(string) bool

// CommandExistsMock creates a mock for isCommandAvailable function
func CommandExistsMock(cmds map[string]bool) CommandAvailabilityChecker <span class="cov0" title="0">{
        return func(cmd string) bool </span><span class="cov0" title="0">{
                available, exists := cmds[cmd]
                if !exists </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">return available</span>
        }
}

// ExecCommandMock holds the data for mocking exec commands
type ExecCommandMock struct {
        // For tracking calls
        CmdCalls []string
        ArgCalls [][]string

        // For configuring responses
        OutputToReturn map[string][]byte
        ErrorToReturn  map[string]error
}

// NewExecCommandMock creates a new mock for exec commands
func NewExecCommandMock() *ExecCommandMock <span class="cov0" title="0">{
        return &amp;ExecCommandMock{
                CmdCalls:       make([]string, 0),
                ArgCalls:       make([][]string, 0),
                OutputToReturn: make(map[string][]byte),
                ErrorToReturn:  make(map[string]error),
        }
}</span>

// GetCommandKey creates a key for lookup in the output/error maps
func (e *ExecCommandMock) GetCommandKey(cmd string, args ...string) string <span class="cov0" title="0">{
        key := cmd
        for _, arg := range args </span><span class="cov0" title="0">{
                key += ":" + arg
        }</span>
        <span class="cov0" title="0">return key</span>
}

// SetOutput sets the output for a command
func (e *ExecCommandMock) SetOutput(output []byte, cmd string, args ...string) <span class="cov0" title="0">{
        key := e.GetCommandKey(cmd, args...)
        e.OutputToReturn[key] = output
}</span>

// SetError sets the error for a command
func (e *ExecCommandMock) SetError(err error, cmd string, args ...string) <span class="cov0" title="0">{
        key := e.GetCommandKey(cmd, args...)
        e.ErrorToReturn[key] = err
}</span>

// CaptureOutput captures stdout and stderr during a function execution
func CaptureOutput(f func()) (string, string) <span class="cov0" title="0">{
        // Save original stdout and stderr
        oldStdout := os.Stdout
        oldStderr := os.Stderr

        // Create pipes
        rOut, wOut, _ := os.Pipe()
        rErr, wErr, _ := os.Pipe()

        // Replace stdout and stderr with pipes
        os.Stdout = wOut
        os.Stderr = wErr

        // Call the function
        f()

        // Close the write end of the pipes
        wOut.Close()
        wErr.Close()

        // Read the output
        var bufOut, bufErr bytes.Buffer
        io.Copy(&amp;bufOut, rOut)
        io.Copy(&amp;bufErr, rErr)

        // Restore original stdout and stderr
        os.Stdout = oldStdout
        os.Stderr = oldStderr

        return bufOut.String(), bufErr.String()
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
Copyright © 2023 ShieldDev

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package main

import "github.com/lirtsman/devhelper-cli/cmd"

func main() <span class="cov0" title="0">{
        cmd.Execute()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
